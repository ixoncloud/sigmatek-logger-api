//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_TCPIPClientInterface"
	Revision           = "1.1"
	GUID               = "{8FC2F34A-F6F1-4780-961A-0742296EBCA9}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(690,120)"
	Comment            = "Interface class for _TCPIP_CLIENT.&#13;&#10;One Instance for for one connection.&#13;&#10;This interface handles the Connection and Data receiving and sending.">
	<Channels>
		<Server Name="ClassSvr" GUID="{90C50082-B08A-4282-BD53-F66CC72272C2}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Object Server. ( not used )"/>
		<Server Name="ErrorCode" GUID="{878BADBA-115A-474D-B1A4-9CBBE7E67BE3}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="shows the last error code."/>
		<Server Name="ErrorGroup" GUID="{FBD01B0D-5772-4474-B0BF-8482E7E6D7C9}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="shows the last error group."/>
		<Server Name="ErrorState" GUID="{5AC1ECF4-AF50-436C-A661-4E28889F4C27}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="shows the last error state."/>
		<Server Name="State" GUID="{0F742D21-6AD6-4432-8E7F-8F51F8569C72}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="shows the State of the Interface Object."/>
		<Client Name="_TCPIPClient" Required="true" Internal="false" Comment="object channel to class _TCPIPClient"/>
	</Channels>
	<RevDoku>
		<Owner Company="SIGMATEK" Author="hoeant"/>
		<Dokumentation Revision="1.1" Date="2019-03-29" Author="HubChr" Company="SIGMATEK" Description="corrected errors in the handling of connectionHandles: negative handles are also allowed!"/>
		<Dokumentation Revision="1.0" Date="2019-01-15" Author="hoeant" Company="SIGMATEK" Description="creation of class"/>
	</RevDoku>
</Class>
*)
_TCPIPClientInterface : CLASS
	TYPE
	  _STATE_TCPIPC_INTF :  //! <Type Public="true" Comment="Type for state server" Name="_STATE_TCPIPC_INTF"/>
	  (
	    _STATE_NO_CONNECTION,  //! <Type Comment="waiting for AddConnection" Name="_STATE_TCPIPC_INTF._STATE_NO_CONNECTION"/>
	    _STATE_DISCONNECTED,  //! <Type Comment="Connection was added but actualy not conneted." Name="_STATE_TCPIPC_INTF._STATE_DISCONNECTED"/>
	    _STATE_CONNECTED  //! <Type Comment="connection is running." Name="_STATE_TCPIPC_INTF._STATE_CONNECTED"/>
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	State 	: SvrCh__STATE_TCPIPC_INTF_PTofCls__TCPIPClientInterface;
	ErrorState 	: SvrCh__FSM_TCPIP_CLIENT_PTofCls__TCPIPClient;
	ErrorGroup 	: SvrCh_DINT;
	ErrorCode 	: SvrCh_DINT;
  //Clients:
	_TCPIPClient 	: CltChCmd__TCPIPClient;
  //Variables:
		ConnectionHandle 	: DINT;			//! <Variable Comment="actual connection handle" Name="ConnectionHandle"/>
  //Functions:
				//! <Function Comment="Call this Function to add a Object for sending/receiving Data to a TCP/IP Server" Name="AddConnection"/>
	FUNCTION VIRTUAL GLOBAL AddConnection
		VAR_INPUT
			pIPAddress 	: ^CHAR;			//! <Variable Comment="Pointer to IP-Address&#13;&#10;Needs to be a dotted string!&#13;&#10;&#13;&#10;e.g. &quot;192.168.2.1&quot;" Name="AddConnection.pIPAddress"/>
			udTimeout 	: UDINT;			//! <Variable Comment="in [ms]&#13;&#10;Timeout to close Connection when no Data is received or sended&#13;&#10;0 ... No Timeout activated (connection will not be closed)" Name="AddConnection.udTimeout"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="-1:&#13;&#10;ther is already a connection.&#13;&#10;&#13;&#10;0...Error&#13;&#10;&#13;&#10;&gt;0...OK ( connection Handle)" Name="AddConnection.dRetcode"/>
		END_VAR;
				//! <Function Comment="create SSL/TLS connection to a server" Name="AddConnectionSSL"/>
	FUNCTION VIRTUAL GLOBAL AddConnectionSSL
		VAR_INPUT
			pIPAddress 	: ^CHAR;			//! <Variable Comment="Pointer to IP-Address&#13;&#10;Needs to be a dotted string!&#13;&#10;&#13;&#10;e.g. &quot;192.168.2.1&quot;" Name="AddConnectionSSL.pIPAddress"/>
			pCACertPEMFilename 	: ^CHAR;			//! <Variable Comment="pointer to filename. (max length 255 byte)" Name="AddConnectionSSL.pCACertPEMFilename"/>
			pClientCertChainPEMFilename 	: ^CHAR;			//! <Variable Comment="pointer to filename. (max length 255 byte)" Name="AddConnectionSSL.pClientCertChainPEMFilename"/>
			pClientCertKeyPEMFilename 	: ^CHAR;			//! <Variable Comment="pointer to filename. (max length 255 byte)" Name="AddConnectionSSL.pClientCertKeyPEMFilename"/>
			pKeyDecryptPwd 	: ^CHAR;			//! <Variable Comment="pointer to  password string (max length 1023 byte)" Name="AddConnectionSSL.pKeyDecryptPwd"/>
			udTimeout 	: UDINT;			//! <Variable Comment="in [ms]&#13;&#10;Timeout to close Connection when no Data is received or sended&#13;&#10;0 ... No Timeout activated (connection will not be closed)" Name="AddConnectionSSL.udTimeout"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="-1:&#13;&#10;ther is already a connection.&#13;&#10;&#13;&#10;0...Error&#13;&#10;&#13;&#10;&gt;0...OK ( connection Handle)" Name="AddConnectionSSL.dRetcode"/>
		END_VAR;
				//! <Function Comment="Call this Function to check if Connection is OK" Name="IsConnected"/>
	FUNCTION VIRTUAL GLOBAL IsConnected
		VAR_OUTPUT
			bRetcode 	: BOOL;			//! <Variable Comment="1 ... connected&#13;&#10;0 ... not connected" Name="IsConnected.bRetcode"/>
		END_VAR;
				//! <Function Comment="For receiving a spezial amount of Data.&#13;&#10;You have to overwrite  the DataHandling Methode, otherwise you get the whole&#13;&#10;recived Data from the Stack." Name="DataHandling"/>
	FUNCTION VIRTUAL GLOBAL DataHandling
		VAR_INPUT
			udAvailableData 	: UDINT;			//! <Variable Comment="actual nr of data byte available on stack" Name="DataHandling.udAvailableData"/>
		END_VAR
		VAR_OUTPUT
			udReadAvailableDataBytes 	: UDINT;			//! <Variable Comment="return the nr of bytes you want to receive" Name="DataHandling.udReadAvailableDataBytes"/>
		END_VAR;
				//! <Function Comment="This Method is called if Data is received (Overwrite it)&#13;&#10;For receiving a spezial amount of Data you have to use the &#13;&#10;DataHandling Methode." Name="Response"/>
	FUNCTION VIRTUAL GLOBAL Response
		VAR_INPUT
			pData 	: ^void;			//! <Variable Comment="Pointer to Data" Name="Response.pData"/>
			udsize 	: UDINT;			//! <Variable Comment="Size of Data" Name="Response.udsize"/>
		END_VAR;
				//! <Function Comment="Send Data over TCP/IP" Name="SendData"/>
	FUNCTION VIRTUAL GLOBAL SendData
		VAR_INPUT
			pData 	: ^void;			//! <Variable Comment="Pointer to Data" Name="SendData.pData"/>
			udSize 	: UDINT;			//! <Variable Comment="Size of Data" Name="SendData.udSize"/>
			bDirect 	: BOOL;			//! <Variable Comment="0 ... Write it to Send Buffer and send it in next Cyclus&#13;&#10;1 ... Send it imidiatly" Name="SendData.bDirect"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="0 ... TCP_CLT_SEND_OK         &#13;&#10;-1... TCP_CLT_INVALID_HANDLE  &#13;&#10;-2... TCP_CLT_NOT_CONNECTED   &#13;&#10;-3... TCP_CLT_SEND_FAILED     &#13;&#10;-4... TCP_CLT_SEND_BUFFER_FULL&#13;&#10;-5... TCP_CLT_DATA_TO_BIG     &#13;&#10;" Name="SendData.dRetcode"/>
		END_VAR;
				//! <Function Comment="Delet (shutdown) one Connection" Name="DelConnection"/>
	FUNCTION VIRTUAL GLOBAL DelConnection
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="TCP_CLT_NO_ERROR:&#13;&#10;connection will be closed.&#13;&#10;&#13;&#10;TCP_CLT_INVALID_HANDLE:&#13;&#10;connection handle is no vailable.&#13;&#10;&#13;&#10;TCP_CLT_ERR_MAIN_INIT:&#13;&#10;ist not possible to call this funktion in the first init call.&#13;&#10;" Name="DelConnection.Retcode"/>
		END_VAR;
				//! <Function Comment="Delete all entries in SendBuffer." Name="FLUSHRingbuffer"/>
	FUNCTION VIRTUAL GLOBAL FLUSHRingbuffer
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="TCP_CLT_NO_ERROR:&#13;&#10;buffer deleted&#13;&#10;&#13;&#10;TCP_CLT_INVALID_HANDLE:&#13;&#10;connection handle is no vailable.&#13;&#10;&#13;&#10;TCP_CLT_ERR_MAIN_INIT:&#13;&#10;ist not possible to call this funktion in the first init call.&#13;&#10;" Name="FLUSHRingbuffer.Retcode"/>
		END_VAR;
				//! <Function Comment="method to set parameters of this connection" Name="SetConnParameter"/>
	FUNCTION VIRTUAL GLOBAL SetConnParameter
		VAR_INPUT
			Cmd 	: DINT;			//! <Variable Comment="0 ... (CLT_TCP_CMD_SETSOCKOPT) socket option&#13;&#10;2 ... (CLT_TCP_CMD_CLOSESOCKETTYPE) close socket type&#13;&#10;3 ... (CLT_TCP_CMD_KEEPALIVEPARA) keep alive parameter" Name="SetConnParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (CLT_TCP_CMD_SETSOCKOPT)&#13;&#10;-) SubCmd = 0:  CLT_TCP_SOCKOPT_NAGLE ... activate/deactivate nagle algorithm&#13;&#10;-) SubCmd = 1:  CLT_TCP_SOCKOPT_KEEPALIVE ... activate/deactivate keepalive message&#13;&#10;-) SubCmd = 2:  CLT_TCP_SOCKOPT_DELAYEDACK ... activate/deactivate delayed acknowledge packet&#13;&#10;-) SubCmd = 3:  CLT_TCP_SOCKOPT_REUSEADDR ... activate/deactivate option reuse address&#13;&#10;&#13;&#10;Cmd = 2 (CLT_TCP_CMD_CLOSESOCKETTYPE)&#13;&#10;-) SubCmd = 0: CLT_TCP_CLOSESOCKETTYPE&#13;&#10;&#13;&#10;Cmd = 3 (CLT_TCP_CMD_KEEPALIVEPARA)&#13;&#10;-) SubCmd = 0:  CLT_TCP_KEEPALIVE_KEEPIDLE&#13;&#10;-) SubCmd = 1:  CLT_TCP_KEEPALIVE_KEEPINTVL&#13;&#10;-) SubCmd = 2:  CLT_TCP_KEEPALIVE_KEEPCNT&#13;&#10;" Name="SetConnParameter.SubCmd"/>
			ParaValue 	: DINT;			//! <Variable Comment="1.. Activate option&#13;&#10;2.. Deactivate option" Name="SetConnParameter.ParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0.. success&#13;&#10;-1.. Invalid Handle&#13;&#10;-10.. Invalid CMD&#13;&#10;-11.. Invalid SubCMD" Name="SetConnParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="method to set parameters of this connection" Name="ReadConnParameter"/>
	FUNCTION VIRTUAL GLOBAL ReadConnParameter
		VAR_INPUT
			Cmd 	: DINT;			//! <Variable Comment="0 ... (CLT_TCP_CMD_SETSOCKOPT) socket option&#13;&#10;2 ... (CLT_TCP_CMD_CLOSESOCKETTYPE) close socket type&#13;&#10;3 ... (CLT_TCP_CMD_KEEPALIVEPARA) keep alive parameter" Name="ReadConnParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (CLT_TCP_CMD_SETSOCKOPT)&#13;&#10;-) SubCmd = 0:  CLT_TCP_SOCKOPT_NAGLE ... activate/deactivate nagle algorithm&#13;&#10;-) SubCmd = 1:  CLT_TCP_SOCKOPT_KEEPALIVE ... activate/deactivate keepalive message&#13;&#10;-) SubCmd = 2:  CLT_TCP_SOCKOPT_DELAYEDACK ... activate/deactivate delayed acknowledge packet&#13;&#10;-) SubCmd = 3:  CLT_TCP_SOCKOPT_REUSEADDR ... activate/deactivate option reuse address&#13;&#10;&#13;&#10;Cmd = 2 (CLT_TCP_CMD_CLOSESOCKETTYPE)&#13;&#10;-) SubCmd = 0: CLT_TCP_CLOSESOCKETTYPE&#13;&#10;&#13;&#10;Cmd = 3 (CLT_TCP_CMD_KEEPALIVEPARA)&#13;&#10;-) SubCmd = 0:  CLT_TCP_KEEPALIVE_KEEPIDLE&#13;&#10;-) SubCmd = 1:  CLT_TCP_KEEPALIVE_KEEPINTVL&#13;&#10;-) SubCmd = 2:  CLT_TCP_KEEPALIVE_KEEPCNT&#13;&#10;" Name="ReadConnParameter.SubCmd"/>
			pParaValue 	: ^DINT;			//! <Variable Comment="pointer to target parameter value" Name="ReadConnParameter.pParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0.. success&#13;&#10;-1.. Invalid Handle&#13;&#10;-10.. Invalid CMD&#13;&#10;-11.. Invalid SubCMD&#13;&#10;-13...command not supported" Name="ReadConnParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="method to read main parameters" Name="ReadMainParameter"/>
	FUNCTION VIRTUAL GLOBAL ReadMainParameter
		VAR_INPUT
			Cmd 	: DINT;			//! <Variable Comment="0 ... (CLT_TCP_CMD_SETSOCKOPT) socket option&#13;&#10;1 ... (CLT_TCP_CMD_TASKPRIO) task priority of async task (in case of using object in async task)&#13;&#10;2 ... (CLT_TCP_CMD_CLOSESOCKETTYPE) close socket type&#13;&#10;3 ... (CLT_TCP_CMD_KEEPALIVEPARA) keep alive parameter" Name="ReadMainParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (CLT_TCP_CMD_SETSOCKOPT)&#13;&#10;-) SubCmd = 0:  CLT_TCP_SOCKOPT_NAGLE ... activate/deactivate nagle algorithm&#13;&#10;-) SubCmd = 1:  CLT_TCP_SOCKOPT_KEEPALIVE ... activate/deactivate keepalive message&#13;&#10;-) SubCmd = 2:  CLT_TCP_SOCKOPT_DELAYEDACK ... activate/deactivate delayed acknowledge packet&#13;&#10;-) SubCmd = 3:  CLT_TCP_SOCKOPT_REUSEADDR ... activate/deactivate option reuse address&#13;&#10;&#13;&#10;Cmd = 1 (CLT_TCP_CMD_TASKPRIO)&#13;&#10;-) SubCmd = 0: task priority of async task&#13;&#10;&#13;&#10;&#13;&#10;Cmd = 2 (CLT_TCP_CMD_CLOSESOCKETTYPE)&#13;&#10;-) SubCmd = 0: CLT_TCP_CLOSESOCKETTYPE&#13;&#10;&#13;&#10;Cmd = 3 (CLT_TCP_CMD_KEEPALIVEPARA)&#13;&#10;-) SubCmd = 0:  CLT_TCP_KEEPALIVE_KEEPIDLE&#13;&#10;-) SubCmd = 1:  CLT_TCP_KEEPALIVE_KEEPINTVL&#13;&#10;-) SubCmd = 2:  CLT_TCP_KEEPALIVE_KEEPCNT&#13;&#10;" Name="ReadMainParameter.SubCmd"/>
			pParaValue 	: ^DINT;			//! <Variable Comment="pointer to target parameter value" Name="ReadMainParameter.pParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0 ... success&#13;&#10;-10 ... invalid CMD&#13;&#10;-11 ... invalid SubCMD&#13;&#10;-90 ... object not initialized (initialization in first Init() call)" Name="ReadMainParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="method to read client settings" Name="GetSetting"/>
	FUNCTION VIRTUAL GLOBAL GetSetting
		VAR_INPUT
			Index 	: DINT;			//! <Variable Comment="setting index&#13;&#10;0 (CLT_TCP_GET_SETTING_PORT) ... port setting&#13;&#10;1 (CLT_TCP_GET_SETTING_BUFSIZE) ... buffer size of send buffer&#13;&#10;2 (CLT_TCP_GET_SETTING_MAXCONN) ... max connection&#13;&#10;3 (CLT_TCP_GET_SETTING_CONFIG) ... config bitfield" Name="GetSetting.Index"/>
			pSetting 	: ^DINT;			//! <Variable Comment="pointer to destination variable" Name="GetSetting.pSetting"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="result of method&#13;&#10;0 ... no error&#13;&#10;-1 ... invalid index" Name="GetSetting.Retcode"/>
		END_VAR;
				//! <Function Comment="Method provides connection informations.&#13;&#10;-) TCP connected &#13;&#10;-) TCP disconnected &#13;&#10;-) connection is deleted &#13;&#10;" Name="InfoCallback"/>
	FUNCTION VIRTUAL GLOBAL InfoCallback
		VAR_INPUT
			FSM_TCP 	: _TCPIPClient::_FSM_TCPIP_CLIENT;			//! <Variable Comment="actual state of TCPIP Client" Name="InfoCallback.FSM_TCP"/>
			InfoPara1 	: DINT;			//! <Variable Comment="-) TCP connected (callback: InfoPara1 = 1)&#13;&#10;-) TCP disconnected (callback InfoPara1 = 0)&#13;&#10;-) connection is deleted (callback InfoPara1 = 2)&#13;&#10;" Name="InfoCallback.InfoPara1"/>
			InfoPara2 	: DINT;			//! <Variable Comment="reserved" Name="InfoCallback.InfoPara2"/>
		END_VAR;
				//! <Function Comment="Method provides connection error states.&#13;&#10;-) TCP error&#13;&#10;-)  internal error&#13;&#10;-) receive timeout (in case of timeout is set)" Name="ErrCallback"/>
	FUNCTION VIRTUAL GLOBAL ErrCallback
		VAR_INPUT
			FSM_TCP 	: _TCPIPClient::_FSM_TCPIP_CLIENT;			//! <Variable Comment="shows the last error state." Name="ErrCallback.FSM_TCP"/>
			ErrGroup 	: DINT;			//! <Variable Comment="ErrorGroup = 0:&#13;&#10;   ErrorCode = TCP error status (defnition in lsl_st_tcp_user.h)&#13;&#10;&#13;&#10;ErrorGroup = 1:&#13;&#10;    ErrorCode = internal error status ( -1: receive timeout (in case of timeout is set))&#13;&#10;&#13;&#10;" Name="ErrCallback.ErrGroup"/>
			ErrCode 	: DINT;			//! <Variable Comment="ErrorGroup = 0:&#13;&#10;   ErrorCode = TCP error status (defnition in lsl_st_tcp_user.h)&#13;&#10;&#13;&#10;ErrorGroup = 1:&#13;&#10;    ErrorCode = internal error status ( -1: receive timeout (in case of timeout is set))" Name="ErrCallback.ErrCode"/>
		END_VAR;
	
	FUNCTION ResetErrorStates;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _TCPIPClient


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _TCPIPClientInterface::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__TCPIPCLIENTINTERFACE
1$UINT, 1$UINT, (SIZEOF(::_TCPIPClientInterface))$UINT, 
5$UINT, 1$UINT, 0$UINT, 
TO_UDINT(670188634), "_TCPIPClientInterface", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_TCPIPClientInterface.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::_TCPIPClientInterface.State.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "State", 
(::_TCPIPClientInterface.ErrorState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2975757027), "ErrorState", 
(::_TCPIPClientInterface.ErrorGroup.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2131616989), "ErrorGroup", 
(::_TCPIPClientInterface.ErrorCode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(224164065), "ErrorCode", 
//Clients:
(::_TCPIPClientInterface._TCPIPClient.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1778057824), "_TCPIPClient", TO_UDINT(1778057824), "_TCPIPClient", 1$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT__TCPIPClientInterface 14

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__TCPIPClientInterface] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _TCPIPClientInterface::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__TCPIPClientInterface, pCmd := #vmt.CmdTable);
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #AddConnection();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #AddConnectionSSL();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #IsConnected();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #DataHandling();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #Response();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #SendData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DelConnection();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #FLUSHRingbuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #SetConnParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReadConnParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #ReadMainParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #GetSetting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #InfoCallback();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #ErrCallback();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorState.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ErrorState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorGroup.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ErrorGroup.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorCode.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ErrorCode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::AddConnection
	VAR_INPUT
		pIPAddress 	: ^CHAR;
		udTimeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR

  dRetcode :=0;
  if State = _STATE_NO_CONNECTION then
    ConnectionHandle := _TCPIPClient.AddConnection(pIPAddress, pCallbackThis:=this, udTimeout);
    if ConnectionHandle <> 0 then    //HubChr v1.1: Changed the test as the return value can be valid and negative
      dRetcode := ConnectionHandle;
      State := _STATE_DISCONNECTED;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::AddConnectionSSL
	VAR_INPUT
		pIPAddress 	: ^CHAR;
		pCACertPEMFilename 	: ^CHAR;
		pClientCertChainPEMFilename 	: ^CHAR;
		pClientCertKeyPEMFilename 	: ^CHAR;
		pKeyDecryptPwd 	: ^CHAR;
		udTimeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
  
  dRetcode :=0;
  if State = _STATE_NO_CONNECTION then
    ConnectionHandle := _TCPIPClient.AddConnectionSSL(  pIPAddress, 
                                                        pCACertPEMFilename, 
                                                        pClientCertChainPEMFilename, 
                                                        pClientCertKeyPEMFilename, 
                                                        pKeyDecryptPwd, 
                                                        pCallbackThis:=this, 
                                                        udTimeout);
    if ConnectionHandle <> 0 then //HubChr v1.1: Changed the test as the return value can be valid and negative
      dRetcode := ConnectionHandle;
      State := _STATE_DISCONNECTED;
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::IsConnected
	VAR_OUTPUT
		bRetcode 	: BOOL;
	END_VAR

  bRetcode := _TCPIPClient.IsConnected(dHandle:=ConnectionHandle);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::DataHandling
	VAR_INPUT
		udAvailableData 	: UDINT;
	END_VAR
	VAR_OUTPUT
		udReadAvailableDataBytes 	: UDINT;
	END_VAR
  
  udReadAvailableDataBytes := udAvailableData;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::Response
	VAR_INPUT
  #pragma warning(disable:73);
		pData 	: ^void;
		udsize 	: UDINT;
  #pragma warning(default:73);
	END_VAR

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::SendData
	VAR_INPUT
		pData 	: ^void;
		udSize 	: UDINT;
		bDirect 	: BOOL;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR

  dRetcode := TCP_CLT_INVALID_HANDLE;
  
  if ConnectionHandle <> 0 then //HubChr v1.1 Changed this test to be <> 0 so that data can be sent when first bit of handle is set.
    dRetcode := _TCPIPClient.SendData(pData, udSize, ConnectionHandle, bDirect);
  end_if;


END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::DelConnection
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  retcode := _TCPIPClient.DelConnection(dHandle:=ConnectionHandle);
  case Retcode of
    TCP_CLT_NO_ERROR:
      ConnectionHandle := 0;
      State := _STATE_NO_CONNECTION; //HubChr v1.1
    TCP_CLT_INVALID_HANDLE:
    TCP_CLT_ERR_MAIN_INIT:
  end_case;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::FLUSHRingbuffer
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := _TCPIPClient.FLUSHRingbuffer(ConnectionHandle);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::SetConnParameter
	VAR_INPUT
		Cmd 	: DINT;
		SubCmd 	: DINT;
		ParaValue 	: DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := _TCPIPClient.SetConnParameter(dHandle:=ConnectionHandle, Cmd, SubCmd, ParaValue);
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::ReadConnParameter
	VAR_INPUT
		Cmd 	: DINT;
		SubCmd 	: DINT;
		pParaValue 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := _TCPIPClient.ReadConnParameter(ConnectionHandle, Cmd, SubCmd, pParaValue);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::ReadMainParameter
	VAR_INPUT
		Cmd 	: DINT;
		SubCmd 	: DINT;
		pParaValue 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := _TCPIPClient.ReadMainParameter(Cmd, SubCmd, pParaValue);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::GetSetting
	VAR_INPUT
		Index 	: DINT;
		pSetting 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := _TCPIPClient.GetSetting(Index, pSetting);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::InfoCallback
	VAR_INPUT
		FSM_TCP 	: _TCPIPClient::_FSM_TCPIP_CLIENT;
		InfoPara1 	: DINT;
		InfoPara2 	: DINT;
	END_VAR

  case FSM_TCP of
    _TCPIPClient::_FSM_TCPIP_CLIENT::_STATE_RECV : 
      
      if InfoPara1 = TCP_CLT_INFO_CONNECT then
        State := _STATE_CONNECTed;
      end_if;
      
    _TCPIPClient::_FSM_TCPIP_CLIENT::_STATE_CLOSE_MAIN_SOCK:
      
      if InfoPara1 = TCP_CLT_INFO_DISCONNECT then
        State := _STATE_DISCONNECTED;
      end_if;
    
    _TCPIPClient::_FSM_TCPIP_CLIENT::_STATE_DEL_CONNECTION:
      if InfoPara1 = TCP_CLT_INFO_DELETED then
        State := _STATE_NO_CONNECTION;
      end_if;
      
      
  end_case;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClientInterface::ErrCallback
	VAR_INPUT
		FSM_TCP 	: _TCPIPClient::_FSM_TCPIP_CLIENT;
		ErrGroup 	: DINT;
		ErrCode 	: DINT;
	END_VAR

  ErrorState := FSM_TCP;
  ErrorGroup := ErrGroup;
  ErrorCode    := ErrCode;

END_FUNCTION

FUNCTION _TCPIPClientInterface::ResetErrorStates

  ErrorState    := _TCPIPClient::_FSM_TCPIP_CLIENT::_STATE_NONE;
  ErrorGroup    := 0;
  ErrorCode     := 0;

END_FUNCTION
