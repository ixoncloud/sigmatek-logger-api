//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

  #define TCPCLT_ERROR_NO            0
  #define TCPCLT_ERROR_INVALID_SOCK  -1
  #define TCPCLT_ERROR_CONNECTION    -2
  #define TCPCLT_ERROR_TIMEOUT       -3

  #define TCP_CLT_SEND_OK               0
  #define TCP_CLT_INVALID_HANDLE        -1
  #define TCP_CLT_NOT_CONNECTED         -2
  #define TCP_CLT_SEND_FAILED           -3
  #define TCP_CLT_SEND_BUFFER_FULL      -4
  #define TCP_CLT_DATA_TO_BIG_FOR_DIRECT_SENDING   -5
  #define TCP_CLT_MAXLEN_SEMANAME     32

  #define TCP_CLT_ERR_SET_PARA_INVALID_CMD     -10
  #define TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD -11

  #define TCP_CLT_ERR_TASK_ALREADY_EXIST       -12

  #define TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED  -13

  #ifndef OS_VERSION_MIN_SALAMANDER
    #define OS_VERSION_MIN_SALAMANDER          0x9000
  #endif

  #define TCP_CLT_NO_ERROR                          0

  // - RETURN VALUES PRIVATE METHOD Read_LSLOBJ_CRC32
  #define TCP_CLT_ERR_GET_LSLOBJ_NAME             -20
  #define TCP_CLT_ERR_INVALID_POINTER             -21

  // - RETURN VALUES PRIVATE METHOD Read_AP_TaskPeriod
  #define TCP_CLT_ERR_TASK_TIME_NO_APP            -31
  #define TCP_CLT_ERR_TASK_TIME_WRONG_TASK_TYPE   -33
  #define TCP_CLT_ERR_TASK_TIME_OBJ_NOT_FOUND     -35

  // - RETURN VALUES PRIVATE METHOD AP_TaskCreate
  #define TCP_CLT_ERR_TASK_CREATE                 -40

  // - RETURN VALUES PRIVATE METHOD AP_SemaCreate
  #define TCP_CLT_ERR_SEMA_CREATE                 -50
  #define TCP_CLT_ERR_SEMA_INVALID_IDX            -51
  #define TCP_CLT_ERR_SEMA_INVALID_NAME           -52

  #define TCP_CLT_SEND_BUFFER_EMPTY                -6
  #define TCP_CLT_ERR_SEND_BUFFER_FATAL_ERROR      -7

  #define TCP_CLT_ERR_NO_SSL_INTERFACE             -8
  #define TCP_CLT_ERR_NO_TCP_INTERFACE             -9

  #define TCP_CLT_ERR_INVALID_PARA_TCP            -60
  #define TCP_CLT_ERR_INVALID_PARA_SSL            -61
  
  #define TCP_CLT_ERR_CONN_MEMORY                 -70
  #define TCP_CLT_ERR_MAX_CONN                    -80
  #define TCP_CLT_ERR_MAIN_INIT                   -90
  
  #define TCP_CLT_ERR_GROUP_OS                      0
  #define TCP_CLT_ERR_GROUP_AP                      1

  #define TCP_CLT_ERR_CODE_AP_TIMEOUT              -1
  
  #ifndef INIT_FIRSTSCAN
    #define INIT_FIRSTSCAN                         12
  #endif

  #ifndef AP_TASK_PRIORITY_DEFAULT
    #define AP_TASK_PRIORITY_DEFAULT               14
  #endif

  #define TCP_CLT_CMD_KEEP_ALIVE_PARA               2
  #define TCP_CLT_SUB_CMD_KEEP_ALIVE_INTERVAL       0
  #define TCP_CLT_SUB_CMD_KEEP_ALIVE_RETRY          1
  #define TCP_CLT_SUB_CMD_KEEP_ALIVE_TIMEOUT        2

  #define TCP_CLT_INFO_DISCONNECT                   0
  #define TCP_CLT_INFO_CONNECT                      1
  #define TCP_CLT_INFO_DELETED                      2
  
  #ifndef KEEPALIVE_INTERVAL_DEFAULT
    #define KEEPALIVE_INTERVAL_DEFAULT           7200
  #endif

  #ifndef KEEPALIVE_RETRYTIME_DEFAULT
    #define KEEPALIVE_RETRYTIME_DEFAULT            75
  #endif

  #ifndef KEEPALIVE_RETRYCNT_DEFUALT
    #define KEEPALIVE_RETRYCNT_DEFUALT             10
  #endif

  #ifndef CLOSE_SOCKET_TYPE_DEFAULT
    #define CLOSE_SOCKET_TYPE_DEFAULT               0
  #endif
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Class\_TCPIPClient\_TCPIPClient.h"
#include "..\..\Class\_TCPIPClient\SalamanderDelay.h"
#include "..\..\Class\_TCPIPClient\lsl_st_ssl_user.h"

(*!
<Class
	Name               = "_TCPIPClient"
	Revision           = "1.1"
	GUID               = "{730104E9-8CFE-4EAC-BC6B-0D4A0F12B6A4}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	DefBackground      = "always"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(568,120)"
	Comment            = "TCP/IP Client for TCP/IP Communication.&#13;&#10;&#13;&#10;It is recommended to use one object per connection.">
	<Channels>
		<Server Name="Control" GUID="{F3BCA3A9-86B1-411B-B4D3-D72796E1D857}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Object Channel&#13;&#10;-) use the channel to call global functions from external&#13;&#10;-) this server shows the TCP client state"/>
		<Server Name="SemaName01" GUID="{C254FD60-38D0-42A6-AD37-F0F54392E23F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="name of mutex to save the internal connection buffer&#13;&#10;&#13;&#10;This name is also listed in PLCTraceView"/>
		<Server Name="SemaName02" GUID="{1A4BBB71-0704-4AA5-9FD4-9A1C0415D984}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="name of mutex to save the internal connection settings (socket options)&#13;&#10;&#13;&#10;This name is also listed in PLCTraceView"/>
		<Server Name="TaskName" GUID="{20B3EDCA-D8B0-47DA-B242-CD7C6EC2495B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="shows task information&#13;&#10;-) use object in cyclic task&#13;&#10;-) use object in async task&#13;&#10;-) task deactivated&#13;&#10;-) async task error status (error creating async task)&#13;&#10;&#13;&#10;In case of using the object in async task, this name is also listed in PLCTraceView"/>
		<Client Name="_MultiTask" Required="false" Internal="false" Comment="object channel to OS interface class _MultiTask"/>
		<Client Name="_StdLib" Required="false" Internal="false" Comment="object channel to OS interface class _StdLib"/>
		<Client Name="_TaskObjectControl" Required="false" Internal="false" Comment="object channel to OS interface class _TaskObjectControl"/>
		<Client Name="CheckSum" Required="true" Internal="true"/>
		<Client Name="Config" Required="false" Internal="false" Comment="object configuration&#13;&#10;bit0 ... task configuration&#13;&#10;0 = use object in cyclic task&#13;&#10;1 = use object in async task"/>
		<Client Name="MaxConnections" Required="true" Internal="false" DefValue="0" Comment="Maximal number of connections. Maximal possible connections are 16.&#13;&#10;&#13;&#10;0 = 16 connections, because of compatibility to older versions."/>
		<Client Name="Port" Required="true" Internal="false" DefValue="502" Comment="port number ... must be connected or initialized"/>
		<Client Name="SigCLib" Required="false" Internal="false" Comment="object channel to OS interface class SigCLib"/>
		<Client Name="SizeOfTXBuffer" Required="false" Internal="false" Comment="size of TX buffer [byte]&#13;&#10;if 0 there will be 1024 Byte allocated"/>
		<Client Name="StrSemaName01" Required="true" Internal="true"/>
		<Client Name="StrSemaName02" Required="true" Internal="true"/>
		<Client Name="StrTaskName" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\lsl_st_tcp_user.h" Include="false"/>
			<File Path=".\Class\_TCPIPClient\_TCPIPClient.h" Include="true"/>
			<File Path=".\Class\_TCPIPClient\SalamanderDelay.h" Include="true"/>
			<File Path=".\Class\_TCPIPClient\lsl_st_ssl_user.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="SIGMATEK" Author="hoeant"/>
		<Dokumentation Revision="1.1" Date="2019-03-29" Author="HubChr" Company="SIGMATEK" Description="SSL encryption now also works"/>
		<Dokumentation Revision="1.0" Date="2019-01-15" Author="hoeant" Company="SIGMATEK" Description="creation of class"/>
	</RevDoku>
	<Network Name="_TCPIPClient">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "CheckSum"
				GUID       = "{FC39352F-F797-497F-B594-E820A7A22227}"
				Class      = "_CheckSum"
				Position   = "(360,240)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrSemaName01"
				GUID       = "{E85D366E-9709-4F3D-AE62-C1B016CACD7B}"
				Class      = "String"
				Position   = "(360,570)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrSemaName02"
				GUID       = "{10DC5FEF-3685-401A-A366-325AC26C1ADC}"
				Class      = "String"
				Position   = "(360,720)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrTaskName"
				GUID       = "{C0143FE0-3A33-4991-A32A-076BDAE27564}"
				Class      = "String"
				Position   = "(360,420)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.CheckSum" Destination="CheckSum.ClassSvr"/>
			<Connection Source="this.StrTaskName" Destination="StrTaskName.Data"/>
			<Connection Source="this.TaskName" Destination="StrTaskName.Data" Vertices="(938,270),(736,510),"/>
			<Connection Source="this.StrSemaName01" Destination="StrSemaName01.Data"/>
			<Connection Source="this.SemaName01" Destination="StrSemaName01.Data" Vertices="(938,330),(736,660),"/>
			<Connection Source="this.StrSemaName02" Destination="StrSemaName02.Data"/>
			<Connection Source="this.SemaName02" Destination="StrSemaName02.Data" Vertices="(938,390),(736,810),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
_TCPIPClient : CLASS
	TYPE
#pragma pack(push, 1)
	  _BUFFER_HEADER : STRUCT
	    DataSize : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	  _FSM_TCPIP_CLIENT :  //! <Type Public="true" Comment="stepping switch for TCP/IP connection" Name="_FSM_TCPIP_CLIENT"/>
	  (
	    _STATE_NONE,
	    _STATE_INIT_SERVER,
	    _STATE_NO_USER_INTERFACE_CONNECTED,
	    _STATE_IDLE,
	    _STATE_MAIN_SOCK,
	    _STATE_LISTEN,
	    _STATE_ACCEPT,
	    _STATE_CONNECT,
	    _STATE_RECV,
	    _STATE_SHUTDOWN,
	    _STATE_CLOSE_MAIN_SOCK,
	    _STATE_CLOSE_SOCK,
	    _STATE_ERROR,
	    _STATE_ERROR_ALLOCATING_MEMORY,
	    _STATE_ERROR_CREATING_MUTEX,
	    _STATE_ERROR_CREATING_TASK,
	    _STATE_SEND,
	    _STATE_MAIN_SOCK_OPT,
	    _STATE_DEL_CONNECTION,
	    _STATE_CONN_SOCK_OPT
	  )$UDINT;
#pragma pack(push, 1)
	  _TX_RINGBUFFER : STRUCT  //! <Type Comment="struct to handle a ringbuffer" Name="_TX_RINGBUFFER"/>
	    udSize : UDINT;
	    udUsed : UDINT;
	    pMem : ^void;
	    pRead : ^void;
	    pWrite : ^void;
	  END_STRUCT;
#pragma pack(pop)
	  _SocketOptions : BDINT
	  [
	    1 Nagle,
	    2 KeepAlive,
	    3 DelayedAck,
	    4 Bit4,
	    5 Bit5,
	    6 Bit6,
	    7 Bit7,
	    8 Bit8,
	    9 Bit9,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
#pragma pack(push, 1)
	  _KeepAlivePara : STRUCT
	    keepIDLE : DINT;
	    keepINTVL : DINT;
	    keepCNT : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _CONNECTION : STRUCT
	    bInUse : BOOL;
	    szIPAddress : ARRAY [0..0x10] OF CHAR;
	    bConnected : BOOL;
	    dSocket : DINT;
	    FSM_TCP : _FSM_TCPIP_CLIENT;
	    udTimeout : UDINT;
	    udTimeStamp : UDINT;
	    pCallbackThis : ^_TCPIPClientInterface;
	    RingbufferForSending : _TX_RINGBUFFER;
	    pSendReceiveBuffer : ^CHAR;
	    pSendReceiveBufferHelp : ^CHAR;
	    BufferHeader : _BUFFER_HEADER;
	    ConnSockOpt : _SocketOptions;
	    bdSettings : BDINT
	    [
	      1 SockOptInit,
	      2 SockOptChanged,
	      3 DelConn,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	      9 Bit9,
	      10 Bit10,
	      11 Bit11,
	      12 Bit12,
	      13 Bit13,
	      14 Bit14,
	      15 Bit15,
	      16 Bit16,
	      17 ConnSSL,
	      18 Bit18,
	      19 Bit19,
	      20 Bit20,
	      21 Bit21,
	      22 Bit22,
	      23 Bit23,
	      24 Bit24,
	      25 Bit25,
	      26 Bit26,
	      27 Bit27,
	      28 Bit28,
	      29 Bit29,
	      30 Bit30,
	      31 Bit31,
	      32 Bit32,
	    ];
	    szCACertPEMFileName : ARRAY [0..255] OF CHAR;
	    szClientCertChainPEMFileName : ARRAY [0..255] OF CHAR;
	    szClientCertKeyPEMFileName : ARRAY [0..255] OF CHAR;
	    szKeyDecryptPwd : ARRAY [0..1023] OF CHAR;
	    pNextConn : ^_CONNECTION;
	    KeepAlivePara : _KeepAlivePara;
	    CloseSocketType : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	  _FSM_CLT_STATE :
	  (
	    _STATE_INIT,
	    _STATE_WORK
	  )$UDINT;
#pragma pack(push, 1)
	  _KeepAliveParaLasalOS : STRUCT
	    interval : UINT;
	    retry : UINT;
	    timeout : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _TCP_CLT_CONNECTS : STRUCT
	    dActConn : DINT;
	    pConnections : ^_CONNECTION;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	Control 	: SvrChCmd__FSM_TCPIP_CLIENT_PTofCls__TCPIPClient;
	TaskName 	: SvrCh_UDINT;
	SemaName01 	: SvrCh_UDINT;
	SemaName02 	: SvrCh_UDINT;
  //Clients:
	Port 	: CltCh_DINT;
	SizeOfTXBuffer 	: CltCh_UDINT;
	MaxConnections 	: CltCh_DINT;
	Config 	: CltCh_DINT;
	_StdLib 	: CltChCmd__StdLib;
	_MultiTask 	: CltChCmd__MultiTask;
	SigCLib 	: CltChCmd_SigCLib;
	CheckSum 	: CltChCmd__CheckSum;
	StrTaskName 	: CltChCmd_String;
	_TaskObjectControl 	: CltChCmd__TaskObjectControl;
	StrSemaName01 	: CltChCmd_String;
	StrSemaName02 	: CltChCmd_String;
  //Variables:
		pActConn 	: ^_CONNECTION;			//! <Variable Comment="includes all Informations to the act Connection" Name="pActConn"/>
		FSMClient 	: _FSM_CLT_STATE;			//! <Variable Comment="SSW for Connection" Name="FSMClient"/>
		udSendError 	: UDINT;			//! <Variable Comment="Counter if sending Data failed" Name="udSendError"/>
		AP_SemaHandle1 	: MT_SEMAHANDLE;			//! <Variable Comment="Handle of the mutex semaphore" Name="AP_SemaHandle1"/>
		pConnectionBuffer 	: ^_CONNECTION;			//! <Variable Comment="Buffer for the informations of all conenctions" Name="pConnectionBuffer"/>
		ActConn 	: DINT;			//! <Variable Comment="Value of actual connected servers" Name="ActConn"/>
		lsl_tcp_user 	: ^LSL_TCP_USER;
		MainSockOpt 	: _SocketOptions;
		usInit 	: USINT;
		bdStatus : BDINT
		[
		  1 SalamanderOS,
		  5 CIL_tcp_user,
		  6 CIL_ssl_user,
		  7 CIL_debug,
		  9 InhibNextConn,
		  13 LSLOBJ_CRC32,
		  14 AP_TaskPeriod,
		  15 CyclicTask,
		  16 AsyncTask,
		  17 Sema01,
		  18 Sema02,
		  25 ErrAsyncTask,
		  26 ErrSema01,
		  27 ErrSema02,
		  28 ErrMem,
		];

		lsl_ssl_user 	: ^LSL_SSL_USER;
		pCIL_DEBUG 	: ^OS_SALAMANDERDEBUG;
		AP_TaskTime 	: UDINT;
		AP_TaskHandle 	: MT_TASKHANDLE;
		MaxConn 	: DINT;
		LastError 	: DINT;
		AP_SemaSockOpt 	: MT_SEMAHANDLE;
		AP_TaskPriority 	: UDINT;			//! <Variable Comment="task priority of async task (in case of using object in async task)" Name="AP_TaskPriority"/>
		KeepAlivePara 	: _KeepAlivePara;
		CloseSocketType 	: UDINT;
  //Functions:
				//! <Function Comment="-) initialize TCP USER pointer to use OS TCP FUNCTIONS&#13;&#10;-) read port number&#13;&#10;-) Allocate Memory for Buffers" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="cyclic tast methode which is called if client &#13;&#10;cConfig = 0" Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Handles the Connection and Data receiving and sending" Name="CyclicCall"/>
	FUNCTION VIRTUAL GLOBAL CyclicCall;
				//! <Function Comment="Call this Function to add a Object for sending/receiving Data to a TCP/IP Server" Name="AddConnection"/>
	FUNCTION VIRTUAL GLOBAL AddConnection
		VAR_INPUT
			pIPAddress 	: ^CHAR;			//! <Variable Comment="Pointer to IP-Address&#13;&#10;Needs to be a dotted string!&#13;&#10;&#13;&#10;e.g. &quot;192.168.2.1&quot;" Name="AddConnection.pIPAddress"/>
			pCallbackThis 	: ^_TCPIPClientInterface;			//! <Variable Comment="This Pointer to Object which should be called" Name="AddConnection.pCallbackThis"/>
			udTimeout 	: UDINT;			//! <Variable Comment="in [ms]&#13;&#10;Timeout to close Connection when no Data is received or sended&#13;&#10;0 ... No Timeout activated (connection will not be closed)" Name="AddConnection.udTimeout"/>
		END_VAR
		VAR_OUTPUT
			dHandle 	: DINT;			//! <Variable Comment="Save this Handle to call the &quot;IsConnected&quot; and &quot;SendData&quot; Function&#13;&#10;&#13;&#10;0...Error&#13;&#10;&gt;0...OK" Name="AddConnection.dHandle"/>
		END_VAR;
				//! <Function Comment="this function writes data into the TX buffer&#13;&#10;&#13;&#10;the first 4 Bytes are always the size of the following Data" Name="RingbufferWrite"/>
	FUNCTION RingbufferWrite
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
				//! <Function Comment="this function reads data from the TX buffer" Name="RingbufferRead"/>
	FUNCTION RingbufferRead
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
				//! <Function Comment="create SSL/TLS connection to a server" Name="AddConnectionSSL"/>
	FUNCTION VIRTUAL GLOBAL AddConnectionSSL
		VAR_INPUT
			pIPAddress 	: ^CHAR;			//! <Variable Comment="Pointer to IP-Address&#13;&#10;Needs to be a dotted string!&#13;&#10;&#13;&#10;e.g. &quot;192.168.2.1&quot;" Name="AddConnectionSSL.pIPAddress"/>
			pCACertPEMFilename 	: ^CHAR;			//! <Variable Comment="pointer to filename. (max length 255 byte)" Name="AddConnectionSSL.pCACertPEMFilename"/>
			pClientCertChainPEMFilename 	: ^CHAR;			//! <Variable Comment="pointer to filename. (max length 255 byte)" Name="AddConnectionSSL.pClientCertChainPEMFilename"/>
			pClientCertKeyPEMFilename 	: ^CHAR;			//! <Variable Comment="pointer to filename. (max length 255 byte)" Name="AddConnectionSSL.pClientCertKeyPEMFilename"/>
			pKeyDecryptPwd 	: ^CHAR;			//! <Variable Comment="pointer to  password string (max length 1023 byte)" Name="AddConnectionSSL.pKeyDecryptPwd"/>
			pCallbackThis 	: ^_TCPIPClientInterface;			//! <Variable Comment="This Pointer to Object which should be called" Name="AddConnectionSSL.pCallbackThis"/>
			udTimeout 	: UDINT;			//! <Variable Comment="in [ms]&#13;&#10;Timeout to close Connection when no Data is received or sended&#13;&#10;0 ... No Timeout activated (connection will not be closed)" Name="AddConnectionSSL.udTimeout"/>
		END_VAR
		VAR_OUTPUT
			dHandle 	: DINT;			//! <Variable Comment="Save this Handle to call the &quot;IsConnected&quot; and &quot;SendData&quot; Function&#13;&#10;&#13;&#10;0...Error&#13;&#10;&gt;0...OK" Name="AddConnectionSSL.dHandle"/>
		END_VAR;
				//! <Function Comment="Call this Function to check if Connection is OK" Name="IsConnected"/>
	FUNCTION VIRTUAL GLOBAL IsConnected
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="Handle from &quot;AddConnection&quot;" Name="IsConnected.dHandle"/>
		END_VAR
		VAR_OUTPUT
			bRetcode 	: BOOL;			//! <Variable Comment="1 ... connected&#13;&#10;0 ... not connected" Name="IsConnected.bRetcode"/>
		END_VAR;
				//! <Function Comment="Function to send data over TCP/IP&#13;&#10;" Name="SendData"/>
	FUNCTION VIRTUAL GLOBAL SendData
		VAR_INPUT
			pData 	: ^void;			//! <Variable Comment="Pointer to Data" Name="SendData.pData"/>
			udSize 	: UDINT;			//! <Variable Comment="Size of Data" Name="SendData.udSize"/>
			dHandle 	: DINT;			//! <Variable Comment="Handle what you get after calling &quot;AddConnection&quot;" Name="SendData.dHandle"/>
			bDirect 	: BOOL;			//! <Variable Comment="0 ... Write it to Send Buffer and send it in next Cycle&#13;&#10;1 ... Send it immediatly" Name="SendData.bDirect"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="0 ... TCP_CLT_SEND_OK         &#13;&#10;-1... TCP_CLT_INVALID_HANDLE  &#13;&#10;-2... TCP_CLT_NOT_CONNECTED   &#13;&#10;-3... TCP_CLT_SEND_FAILED     &#13;&#10;-4... TCP_CLT_SEND_BUFFER_FULL&#13;&#10;-5... TCP_CLT_DATA_TO_BIG     &#13;&#10;" Name="SendData.dRetcode"/>
		END_VAR;
				//! <Function Comment="Delet (shutdown) one Connection" Name="DelConnection"/>
	FUNCTION VIRTUAL GLOBAL DelConnection
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="Handle from &quot;AddConnection&quot;" Name="DelConnection.dHandle"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="TCP_CLT_NO_ERROR:&#13;&#10;connection will be closed.&#13;&#10;&#13;&#10;TCP_CLT_INVALID_HANDLE:&#13;&#10;connection handle is no vailable.&#13;&#10;&#13;&#10;TCP_CLT_ERR_MAIN_INIT:&#13;&#10;ist not possible to call this funktion in the first init call.&#13;&#10;" Name="DelConnection.Retcode"/>
		END_VAR;
				//! <Function Comment="Delete all entries in SendBuffer for the chosen connection&#13;&#10;" Name="FLUSHRingbuffer"/>
	FUNCTION VIRTUAL GLOBAL FLUSHRingbuffer
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="Handle what you get after calling &quot;AddConnection&quot;" Name="FLUSHRingbuffer.dHandle"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="TCP_CLT_NO_ERROR:&#13;&#10;buffer deleted&#13;&#10;&#13;&#10;TCP_CLT_INVALID_HANDLE:&#13;&#10;connection handle is no vailable.&#13;&#10;&#13;&#10;TCP_CLT_ERR_MAIN_INIT:&#13;&#10;ist not possible to call this funktion in the first init call.&#13;&#10;" Name="FLUSHRingbuffer.Retcode"/>
		END_VAR;
				//! <Function Comment="initialize connection structure" Name="INITConnection"/>
	FUNCTION INITConnection
		VAR_INPUT
			pConnection 	: ^_CONNECTION;
		END_VAR;
				//! <Function Comment="checks the Handle for validity" Name="CheckHandleValid"/>
	FUNCTION CheckHandleValid
		VAR_INPUT
			dHandle 	: DINT;
		END_VAR
		VAR_OUTPUT
			bRetcode 	: BOOL;
		END_VAR;
				//! <Function Comment="send Data via OS-Function" Name="SendTCP"/>
	FUNCTION SendTCP
		VAR_INPUT
			pConnection 	: ^_CONNECTION;
			pData 	: ^CHAR;
			udSize 	: UDINT;
			udTimeout 	: UDINT;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
				//! <Function Comment="method to set parameters of a single connection" Name="SetConnParameter"/>
	FUNCTION VIRTUAL GLOBAL SetConnParameter
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="connection handle" Name="SetConnParameter.dHandle"/>
			Cmd 	: DINT;			//! <Variable Comment="0 ... (CLT_TCP_CMD_SETSOCKOPT) socket option&#13;&#10;2 ... (CLT_TCP_CMD_CLOSESOCKETTYPE) close socket type&#13;&#10;3 ... (CLT_TCP_CMD_KEEPALIVEPARA) keep alive parameter" Name="SetConnParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (CLT_TCP_CMD_SETSOCKOPT)&#13;&#10;-) SubCmd = 0:  CLT_TCP_SOCKOPT_NAGLE ... activate/deactivate nagle algorithm&#13;&#10;-) SubCmd = 1:  CLT_TCP_SOCKOPT_KEEPALIVE ... activate/deactivate keepalive message&#13;&#10;-) SubCmd = 2:  CLT_TCP_SOCKOPT_DELAYEDACK ... activate/deactivate delayed acknowledge packet&#13;&#10;-) SubCmd = 3:  CLT_TCP_SOCKOPT_REUSEADDR ... activate/deactivate option reuse address&#13;&#10;&#13;&#10;Cmd = 2 (CLT_TCP_CMD_CLOSESOCKETTYPE)&#13;&#10;-) SubCmd = 0: CLT_TCP_CLOSESOCKETTYPE&#13;&#10;&#13;&#10;Cmd = 3 (CLT_TCP_CMD_KEEPALIVEPARA)&#13;&#10;-) SubCmd = 0:  CLT_TCP_KEEPALIVE_KEEPIDLE&#13;&#10;-) SubCmd = 1:  CLT_TCP_KEEPALIVE_KEEPINTVL&#13;&#10;-) SubCmd = 2:  CLT_TCP_KEEPALIVE_KEEPCNT&#13;&#10;" Name="SetConnParameter.SubCmd"/>
			ParaValue 	: DINT;			//! <Variable Comment="1.. Activate option&#13;&#10;2.. Deactivate option" Name="SetConnParameter.ParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0.. success&#13;&#10;-1.. Invalid Handle&#13;&#10;-10.. Invalid CMD&#13;&#10;-11.. Invalid SubCMD&#13;&#10;-13...command not supported" Name="SetConnParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="method to read parameters of a single connection" Name="ReadConnParameter"/>
	FUNCTION VIRTUAL GLOBAL ReadConnParameter
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="connection handle" Name="ReadConnParameter.dHandle"/>
			Cmd 	: DINT;			//! <Variable Comment="0 ... (CLT_TCP_CMD_SETSOCKOPT) socket option&#13;&#10;2 ... (CLT_TCP_CMD_CLOSESOCKETTYPE) close socket type&#13;&#10;3 ... (CLT_TCP_CMD_KEEPALIVEPARA) keep alive parameter" Name="ReadConnParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (CLT_TCP_CMD_SETSOCKOPT)&#13;&#10;-) SubCmd = 0:  CLT_TCP_SOCKOPT_NAGLE ... activate/deactivate nagle algorithm&#13;&#10;-) SubCmd = 1:  CLT_TCP_SOCKOPT_KEEPALIVE ... activate/deactivate keepalive message&#13;&#10;-) SubCmd = 2:  CLT_TCP_SOCKOPT_DELAYEDACK ... activate/deactivate delayed acknowledge packet&#13;&#10;-) SubCmd = 3:  CLT_TCP_SOCKOPT_REUSEADDR ... activate/deactivate option reuse address&#13;&#10;&#13;&#10;Cmd = 2 (CLT_TCP_CMD_CLOSESOCKETTYPE)&#13;&#10;-) SubCmd = 0: CLT_TCP_CLOSESOCKETTYPE&#13;&#10;&#13;&#10;Cmd = 3 (CLT_TCP_CMD_KEEPALIVEPARA)&#13;&#10;-) SubCmd = 0:  CLT_TCP_KEEPALIVE_KEEPIDLE&#13;&#10;-) SubCmd = 1:  CLT_TCP_KEEPALIVE_KEEPINTVL&#13;&#10;-) SubCmd = 2:  CLT_TCP_KEEPALIVE_KEEPCNT&#13;&#10;" Name="ReadConnParameter.SubCmd"/>
			pParaValue 	: ^DINT;			//! <Variable Comment="pointer to target parameter value" Name="ReadConnParameter.pParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0.. success&#13;&#10;-1.. Invalid Handle&#13;&#10;-10.. Invalid CMD&#13;&#10;-11.. Invalid SubCMD&#13;&#10;-13...command not supported" Name="ReadConnParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="Method to set main parameters. Main parameters will be used for every new connection." Name="SetMainParameter"/>
	FUNCTION VIRTUAL GLOBAL SetMainParameter
		VAR_INPUT
			Cmd 	: DINT;			//! <Variable Comment="0 ... (CLT_TCP_CMD_SETSOCKOPT) socket option&#13;&#10;1 ... (CLT_TCP_CMD_TASKPRIO) task priority of async task (in case of using object in async task)&#13;&#10;2 ... (CLT_TCP_CMD_CLOSESOCKETTYPE) close socket type&#13;&#10;3 ... (CLT_TCP_CMD_KEEPALIVEPARA) keep alive parameter&#13;&#10;" Name="SetMainParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (CLT_TCP_CMD_SETSOCKOPT)&#13;&#10;-) SubCmd = 0:  CLT_TCP_SOCKOPT_NAGLE ... activate/deactivate nagle algorithm&#13;&#10;-) SubCmd = 1:  CLT_TCP_SOCKOPT_KEEPALIVE ... activate/deactivate keepalive message&#13;&#10;-) SubCmd = 2:  CLT_TCP_SOCKOPT_DELAYEDACK ... activate/deactivate delayed acknowledge packet&#13;&#10;-) SubCmd = 3:  CLT_TCP_SOCKOPT_REUSEADDR ... activate/deactivate option reuse address&#13;&#10;&#13;&#10;Cmd = 1 (CLT_TCP_CMD_TASKPRIO)&#13;&#10;-) SubCmd = 0: task priority of async task&#13;&#10;&#13;&#10;&#13;&#10;Cmd = 2 (CLT_TCP_CMD_CLOSESOCKETTYPE)&#13;&#10;-) SubCmd = 0: CLT_TCP_CLOSESOCKETTYPE&#13;&#10;&#13;&#10;Cmd = 3 (CLT_TCP_CMD_KEEPALIVEPARA)&#13;&#10;-) SubCmd = 0:  CLT_TCP_KEEPALIVE_KEEPIDLE&#13;&#10;-) SubCmd = 1:  CLT_TCP_KEEPALIVE_KEEPINTVL&#13;&#10;-) SubCmd = 2:  CLT_TCP_KEEPALIVE_KEEPCNT&#13;&#10;" Name="SetMainParameter.SubCmd"/>
			ParaValue 	: DINT;			//! <Variable Comment="Cmd = 0 (socket option)&#13;&#10;-) 1 ... Activate option&#13;&#10;-) 2 ... Deactivate option&#13;&#10;&#13;&#10;Cmd = 1 (task priority of async task)&#13;&#10;-) task priority 1-14" Name="SetMainParameter.ParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0 ... success&#13;&#10;-10 ... invalid CMD&#13;&#10;-11 ... invalid SubCMD&#13;&#10;-12 ... error set task priority - task already created&#13;&#10;-90 ... object not initialized (initialization in first Init() call)" Name="SetMainParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="Sets the socket options of the main socket" Name="SetSocketOptions"/>
	FUNCTION SetSocketOptions
		VAR_INPUT
			dHandle 	: DINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION Read_LSLOBJ_CRC32
		VAR_INPUT
			pCRC32 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION Read_AP_TaskPeriod
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION GetMultiTaskErrorCode
		VAR_INPUT
			pErrTxt 	: ^CHAR;
		END_VAR;
	
	FUNCTION AP_TaskCreate
		VAR_INPUT
			pTaskName 	: ^CHAR;
			pCallback 	: ^void;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION __CDECL AP_TaskCallback
		VAR_INPUT
			Param0 	: ^void;
		END_VAR;
	
	FUNCTION AP_TaskDelay
		VAR_INPUT
			udTaskDelay 	: UDINT;
		END_VAR;
	
	FUNCTION AP_SemaCreate
		VAR_INPUT
			pSemaName 	: ^CHAR;
			Index 	: DINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION RingbufferReadEntry
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
			pData 	: ^void;
			pSize 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION RingbufferWriteEntry
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION AP_SemaWait
		VAR_INPUT
			SemaHandle 	: MT_SEMAHANDLE;
		END_VAR;
	
	FUNCTION AP_SemaSignal
		VAR_INPUT
			SemaHandle 	: MT_SEMAHANDLE;
		END_VAR;
	
	FUNCTION DelConnIntern
		VAR_INPUT
			pDelConn 	: ^_CONNECTION;
		END_VAR;
	
	FUNCTION AddConnIntern
		VAR_INPUT
			pIPAddress 	: ^CHAR;
			pCACertPEMFilename 	: ^CHAR;
			pClientCertChainPEMFilename 	: ^CHAR;
			pClientCertKeyPEMFilename 	: ^CHAR;
			pKeyDecryptPwd 	: ^CHAR;
			pCallbackThis 	: ^_TCPIPClientInterface;
			udTimeout 	: UDINT;
			ConnSSL 	: BOOL;
		END_VAR
		VAR_OUTPUT
			dHandle 	: DINT;
		END_VAR;
	
	FUNCTION CheckParaConnSSL
		VAR_INPUT
			pCACertPEMFilename 	: ^CHAR;
			pClientCertChainPEMFilename 	: ^CHAR;
			pClientCertKeyPEMFilename 	: ^CHAR;
			pKeyDecryptPwd 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION FindFirstConn
		VAR_OUTPUT
			pFirstConn 	: ^_CONNECTION;
		END_VAR;
	
	FUNCTION CheckParaConnTCP
		VAR_INPUT
			pIPAddress 	: ^CHAR;
			pCallbackThis 	: ^void;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Read error codes if the result of a global function call was negative&#13;&#10;and the global function returns no specified error code.&#13;&#10;-) AddConnection()" Name="GetLastError"/>
	FUNCTION GLOBAL GetLastError
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="last error code" Name="GetLastError.Retcode"/>
		END_VAR;
	
	FUNCTION ConnErrCallback
		VAR_INPUT
			pConn 	: ^_CONNECTION;
			ErrGroup 	: DINT;
			ErrCode 	: DINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
				//! <Function Comment="method to read main parameters" Name="ReadMainParameter"/>
	FUNCTION VIRTUAL GLOBAL ReadMainParameter
		VAR_INPUT
			Cmd 	: DINT;			//! <Variable Comment="0 ... (CLT_TCP_CMD_SETSOCKOPT) socket option&#13;&#10;1 ... (CLT_TCP_CMD_TASKPRIO) task priority of async task (in case of using object in async task)&#13;&#10;2 ... (CLT_TCP_CMD_CLOSESOCKETTYPE) close socket type&#13;&#10;3 ... (CLT_TCP_CMD_KEEPALIVEPARA) keep alive parameter" Name="ReadMainParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (CLT_TCP_CMD_SETSOCKOPT)&#13;&#10;-) SubCmd = 0:  CLT_TCP_SOCKOPT_NAGLE ... activate/deactivate nagle algorithm&#13;&#10;-) SubCmd = 1:  CLT_TCP_SOCKOPT_KEEPALIVE ... activate/deactivate keepalive message&#13;&#10;-) SubCmd = 2:  CLT_TCP_SOCKOPT_DELAYEDACK ... activate/deactivate delayed acknowledge packet&#13;&#10;-) SubCmd = 3:  CLT_TCP_SOCKOPT_REUSEADDR ... activate/deactivate option reuse address&#13;&#10;&#13;&#10;Cmd = 1 (CLT_TCP_CMD_TASKPRIO)&#13;&#10;-) SubCmd = 0: task priority of async task&#13;&#10;&#13;&#10;&#13;&#10;Cmd = 2 (CLT_TCP_CMD_CLOSESOCKETTYPE)&#13;&#10;-) SubCmd = 0: CLT_TCP_CLOSESOCKETTYPE&#13;&#10;&#13;&#10;Cmd = 3 (CLT_TCP_CMD_KEEPALIVEPARA)&#13;&#10;-) SubCmd = 0:  CLT_TCP_KEEPALIVE_KEEPIDLE&#13;&#10;-) SubCmd = 1:  CLT_TCP_KEEPALIVE_KEEPINTVL&#13;&#10;-) SubCmd = 2:  CLT_TCP_KEEPALIVE_KEEPCNT&#13;&#10;" Name="ReadMainParameter.SubCmd"/>
			pParaValue 	: ^DINT;			//! <Variable Comment="pointer to target parameter value" Name="ReadMainParameter.pParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0 ... success&#13;&#10;-10 ... invalid CMD&#13;&#10;-11 ... invalid SubCMD&#13;&#10;-90 ... object not initialized (initialization in first Init() call)" Name="ReadMainParameter.Retcode"/>
		END_VAR;
	
	FUNCTION ConnInfoCallback
		VAR_INPUT
			pConn 	: ^_CONNECTION;
			InfoPara1 	: DINT;
			InfoPara2 	: DINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION AP_NReadAvailable
		VAR_INPUT
			pConn 	: ^_CONNECTION;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
				//! <Function Comment="method to read client settings" Name="GetSetting"/>
	FUNCTION VIRTUAL GLOBAL GetSetting
		VAR_INPUT
			Index 	: DINT;			//! <Variable Comment="setting index&#13;&#10;0 (CLT_TCP_GET_SETTING_PORT) ... port setting&#13;&#10;1 (CLT_TCP_GET_SETTING_BUFSIZE) ... buffer size of send buffer&#13;&#10;2 (CLT_TCP_GET_SETTING_MAXCONN) ... max connection&#13;&#10;3 (CLT_TCP_GET_SETTING_CONFIG) ... config bitfield" Name="GetSetting.Index"/>
			pSetting 	: ^DINT;			//! <Variable Comment="pointer to destination variable" Name="GetSetting.pSetting"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="result of method&#13;&#10;0 ... no error&#13;&#10;-1 ... invalid index" Name="GetSetting.Retcode"/>
		END_VAR;
	
	FUNCTION SendSSL
		VAR_INPUT
			pConnection 	: ^_CONNECTION;
			pData 	: ^CHAR;
			udSize 	: UDINT;
			udTimeout 	: UDINT;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _CheckSum
#pragma using String
#pragma usingLtd _MultiTask
#pragma usingLtd _StdLib
#pragma usingLtd _TaskObjectControl
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _TCPIPClient::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__TCPIPCLIENT
1$UINT, 1$UINT, (SIZEOF(::_TCPIPClient))$UINT, 
4$UINT, 12$UINT, 0$UINT, 
TO_UDINT(1778057824), "_TCPIPClient", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_TCPIPClient.Control.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3533623889), "Control", 
(::_TCPIPClient.TaskName.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(3136881463), "TaskName", 
(::_TCPIPClient.SemaName01.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(3023984995), "SemaName01", 
(::_TCPIPClient.SemaName02.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(758581465), "SemaName02", 
//Clients:
(::_TCPIPClient.Port.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1963241592), "Port", 
(::_TCPIPClient.SizeOfTXBuffer.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2996167065), "SizeOfTXBuffer", 
(::_TCPIPClient.MaxConnections.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(619070880), "MaxConnections", 
(::_TCPIPClient.Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(611510522), "Config", 
(::_TCPIPClient._StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3689364044), "_StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::_TCPIPClient._MultiTask.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2641766936), "_MultiTask", TO_UDINT(2641766936), "_MultiTask", 1$UINT, 1$UINT, 
(::_TCPIPClient.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 32$UINT, 
(::_TCPIPClient.CheckSum.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(408699862), "CheckSum", TO_UDINT(916194998), "_CheckSum", 1$UINT, 0$UINT, 
(::_TCPIPClient.StrTaskName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3109787989), "StrTaskName", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_TCPIPClient._TaskObjectControl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1584830088), "_TaskObjectControl", TO_UDINT(1584830088), "_TaskObjectControl", 1$UINT, 1$UINT, 
(::_TCPIPClient.StrSemaName01.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4079954366), "StrSemaName01", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_TCPIPClient.StrSemaName02.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1780905988), "StrSemaName02", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
END_FUNCTION


#define USER_CNT__TCPIPClient 12

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__TCPIPClient] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _TCPIPClient::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__TCPIPClient, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #CyclicCall();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #AddConnection();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #AddConnectionSSL();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #IsConnected();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #SendData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #DelConnection();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #FLUSHRingbuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #SetConnParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #ReadConnParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #SetMainParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #ReadMainParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #GetSetting();

#pragma warning (default : 74)
	Control.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Control.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

#pragma usingLtd _TCPIPClientInterface

//{{LSL_IMPLEMENTATION
#pragma usingltd _TCPIPClientInterface


FUNCTION VIRTUAL GLOBAL _TCPIPClient::Init
VAR
	pConn                 : ^_CONNECTION;
  i                     : UDINT;
  udStrLen              : UDINT;
  dRet                  : DINT;
  szCRC32               : ARRAY [0..15] OF CHAR;
  szTaskName            : ARRAY [0..63] OF CHAR;
  szErrCode             : ARRAY [0..31] OF CHAR;
  szSemaName            : ARRAY [0..63] OF CHAR;
END_VAR

  // -------------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------
  // - F I R S T   I N I T   R U N   ( M A I N   I N I T )
  // -------------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------
  Control := _STATE_INIT_SERVER;
  if (usInit = 0) then

    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - SET DEFAULT SETTINGS
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    MainSockOpt.Nagle      := true;
    MainSockOpt.KeepAlive  := false;
    MainSockOpt.DelayedAck := true;

    AP_TaskPriority         := AP_TASK_PRIORITY_DEFAULT;

    KeepAlivePara.keepIDLE  := KEEPALIVE_INTERVAL_DEFAULT;
    KeepAlivePara.keepINTVL := KEEPALIVE_RETRYTIME_DEFAULT;
    KeepAlivePara.keepCNT   := KEEPALIVE_RETRYCNT_DEFUALT;

    CloseSocketType         := CLOSE_SOCKET_TYPE_DEFAULT;

    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - READ CONFIGURATION PARAMETER
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    Port           := Port.Read();
    Config         := Config.Read();
    MaxConnections := MaxConnections.Read();
    SizeOfTXBuffer := SizeOfTXBuffer.Read();


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - CHECK GENERAL PARAMETER CONFIGURATION
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    if MaxConnections <= 0 then
      MaxConnections := 16;
    elsif MaxConnections > 16 then
      MaxConnections := 16;
    end_if;
    MaxConn := MaxConnections;

    if (SizeOfTXBuffer = 0) then
      SizeOfTXBuffer := 1024;
    end_if;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - READ OS INFORMATION
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    if (_RtOSVersion >= OS_VERSION_MIN_SALAMANDER) then
      bdStatus.SalamanderOS := true;
    end_if;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - READ OS CIL INTERFACE INFORMATION
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    if OS_CILGET("TCP_USER", #lsl_tcp_user) then 
      lsl_tcp_user := NIL;
    else
      bdStatus.CIL_tcp_user := true;
    end_if;

    if OS_CILGET("SSL_USER", #lsl_ssl_user) then 
      lsl_ssl_user := NIL;
    else
      bdStatus.CIL_ssl_user := true;
    end_if;

    if OS_CILGET("SALAMANDERDEBUG", #pCIL_DEBUG) then
      pCIL_DEBUG := NIL;
    else
      bdStatus.CIL_debug := true;
    end_if;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - ALLOCATE MEMORY FOR CONNECTION STRUCTURE
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    pConnectionBuffer$^void := _StdLib.Malloc(size:=(sizeof(_CONNECTION) * MaxConn$UDINT));
    if (pConnectionBuffer = NIL) then
      bdStatus.ErrMem := true;
    end_if;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - ALLOCATE MEMORY FOR SEND BUFFER
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    for i := 0 to (MaxConn$USINT-1) do
      pConn := pConnectionBuffer + (i * sizeof(_CONNECTION));

      pConn^.RingbufferForSending.pMem$^void  := _StdLib.Malloc(size := SizeOfTXBuffer);        
      if (pConn^.RingbufferForSending.pMem = NIL) then
        bdStatus.ErrMem := true;
        exit;
      else
        //###################################################################################
        //### initialize send buffer (RINGBUFFER)
        //###################################################################################
        pConn^.RingbufferForSending.udSize := to_UDINT(SizeOfTXBuffer);
        pConn^.RingbufferForSending.udUsed := 0;
        pConn^.RingbufferForSending.pRead  := pConn^.RingbufferForSending.pMem;
        pConn^.RingbufferForSending.pWrite := pConn^.RingbufferForSending.pMem;
        pConn^.pSendReceiveBuffer$^void := _StdLib.Malloc(size:=SizeOfTXBuffer);
        if (pConn^.pSendReceiveBuffer = NIL) then
          bdStatus.ErrMem := true;
          exit;
        end_if;
      end_if;

      //##################################################################################
      //### initialize connection structure
      //##################################################################################
      INITConnection(pConn);

    end_for;

  end_if;

  usInit += 1;




  // -------------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------
  // - F I R S T S C A N
  // -------------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------
  if (_firstscan) then 

    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - READ THE LASAL OBJECT CRC32
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    dRet := Read_LSLOBJ_CRC32(#szCRC32[0]);
    case dRet of
      (*==================================================================*)
      TCP_CLT_NO_ERROR: // - NO ERROR
      (*==================================================================*)
        bdStatus.LSLOBJ_CRC32 := true;
      (*==================================================================*)
      else // - ERROR WHILE READING THE LASAL OBJECT CRC32 (USE THIS PTR)
      (*==================================================================*)
        SigCLib.IToA(this$DINT, #szCRC32[0], 0x10);
    end_case;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - MUTEX CONNECTION INIT
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    SigCLib.StrCpy(#szSemaName[0], "USR_SEMA_");
    SigCLib.StrCat(#szSemaName[0], #szCRC32[0]);
    SigCLib.StrCat(#szSemaName[0], "_01");
    dRet := AP_SemaCreate(#szSemaName[4], 0);
    if (dRet = TCP_CLT_NO_ERROR) then
      bdStatus.Sema01 := true;
    else
      bdStatus.ErrSema01 := true;
      GetMultiTaskErrorCode(#szErrCode[0]);
      SigCLib.StrCpy(#szTaskName[0], "SEMA ERR: CREATE SEMA (");
      SigCLib.StrCat(#szTaskName[0], #szErrCode[0]);
      SigCLib.StrCat(#szTaskName[0], ")");
    end_if;

    udStrLen := SigCLib.StrLen(#szSemaName[0]);
    StrSemaName01.WriteDataOff(udStrLen, 0, #szSemaName[0]);


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - MUTEX SOCKET OPTION INIT
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    SigCLib.StrCpy(#szSemaName[0], "USR_SEMA_");
    SigCLib.StrCat(#szSemaName[0], #szCRC32[0]);
    SigCLib.StrCat(#szSemaName[0], "_02");
    dRet := AP_SemaCreate(#szSemaName[4], 1);
    if (dRet = TCP_CLT_NO_ERROR) then
      bdStatus.Sema02 := true;
    else
      bdStatus.ErrSema02 := true;
      GetMultiTaskErrorCode(#szErrCode[0]);
      SigCLib.StrCpy(#szTaskName[0], "SEMA ERR: CREATE SEMA (");
      SigCLib.StrCat(#szTaskName[0], #szErrCode[0]);
      SigCLib.StrCat(#szTaskName[0], ")");
    end_if;

    udStrLen := SigCLib.StrLen(#szSemaName[0]);
    StrSemaName02.WriteDataOff(udStrLen, 0, #szSemaName[0]);


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - TASK INIT
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    dRet := Read_AP_TaskPeriod();
    if (dRet = TCP_CLT_NO_ERROR) then
      bdStatus.AP_TaskPeriod := true;
      if (Config AND 0x1) then
        // - CYCLIC CALL IN PARALLEL TASK
        SigCLib.StrCpy(#szTaskName[0], "USR_TASK_");
        SigCLib.StrCat(#szTaskName[0], #szCRC32[0]);
        dRet := AP_TaskCreate(#szTaskName[4], #AP_TaskCallback());
        if (dRet = TCP_CLT_NO_ERROR) then
          bdStatus.AsyncTask := true;
        else
          bdStatus.ErrAsyncTask := true;
          GetMultiTaskErrorCode(#szErrCode[0]);
          SigCLib.StrCpy(#szTaskName[0], "TASK ERR: CREATE TASK (");
          SigCLib.StrCat(#szTaskName[0], #szErrCode[0]);
          SigCLib.StrCat(#szTaskName[0], ")");
        end_if;
      else
        // - CYCLIC CALL IN CYCLIC TASK
        bdStatus.CyclicTask := true;
        SigCLib.StrCpy(#szTaskName[0], "CyclicTask");
      end_if;
    else

      case dRet of
        (*==================================================================*)
        TCP_CLT_ERR_TASK_TIME_NO_APP:
        (*==================================================================*)
          SigCLib.StrCpy(#szTaskName[0], "TASK ERR: LSLOBJ (NO APPLICATION)");
        (*==================================================================*)
        TCP_CLT_ERR_TASK_TIME_WRONG_TASK_TYPE:
        (*==================================================================*)
          SigCLib.StrCpy(#szTaskName[0], "TASK ERR: LSLOBJ (WRONG TASK TYPE)");
        (*==================================================================*)
        TCP_CLT_ERR_TASK_TIME_OBJ_NOT_FOUND:
        (*==================================================================*)
          SigCLib.StrCpy(#szTaskName[0], "task deactivated");
        (*==================================================================*)
        else
        (*==================================================================*)
          SigCLib.StrCpy(#szTaskName[0], "TASK ERR: LSLOBJ (UNKNOWN ERROR)");
      end_case;

    end_if;

    udStrLen := SigCLib.StrLen(#szTaskName[0]);
    StrTaskName.WriteDataOff(udStrLen, 0, #szTaskName[0]);

  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClient::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  if (bdStatus.CyclicTask = true) then
    CyclicCall();
  end_if;

	state := READY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClient::CyclicCall
VAR
  dRet          : DINT;
  dBytes        : DINT;
  UserDataToRead : udint;
  pCACert, pClientCertChain, pClientCertKey, pDecryptPass : ^CHAR;
END_VAR

  case FSMClient of

    //*******************************************************************************************************************************
    _STATE_INIT: //### initialization state
    //*******************************************************************************************************************************
      if (bdStatus.ErrAsyncTask = true) then
        Control := _STATE_ERROR_CREATING_TASK;
      elsif (bdStatus.ErrSema01 = true) | (bdStatus.ErrSema02 = true) then
        Control := _STATE_ERROR_CREATING_MUTEX;
      elsif (bdStatus.ErrMem = true) then
        Control := _STATE_ERROR_ALLOCATING_MEMORY;
      else
        if (lsl_tcp_user <> NIL) then
          if (ActConn) then
            pActConn := FindFirstConn();
            if (pActConn <> NIL) then
              FSMClient := _STATE_WORK;
            end_if;
          else
            pActConn := NIL;
          end_if;
        end_if;
      end_if;


    //*******************************************************************************************************************************
    _STATE_WORK: //### work state
    //*******************************************************************************************************************************

      //############################################################################################
      //##                                                                                        ##
      //##    this finite state machine is used for the main TCP/IP connection:                   ##
      //##                                                                                        ##
      //##    -> allocate sockets                                                                 ##
      //##    -> build a connection to a specified socket                                         ##
      //##    -> receive data from server                                                         ##
      //##    -> disable receives and sends on socket                                             ##
      //##    -> close socket                                                                     ##
      //##                                                                                        ##
      //############################################################################################

        case pActConn^.FSM_TCP of

          //****************************************************************************
          _STATE_IDLE: // idle state
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_DEL_CONNECTION;
            else
              if (pActConn^.bConnected = false) then
                pActConn^.FSM_TCP := _STATE_MAIN_SOCK;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_MAIN_SOCK: // allocate socket
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_DEL_CONNECTION;
            else
              if (pActConn^.bdSettings.ConnSSL = false) then
                pActConn^.dSocket := OS_TCP_USER_SOCKET();
              else
                
                //HubChr v1.1: Fixed incorrect handling of OS_SSL_USER_CREATE_CONN_STRUCT method input vars
                
                pCACert := pClientCertChain := pClientCertKey := pDecryptPass := NIL;
                
                if pActConn^.szCACertPEMFilename[0] <> 0x00 then
                  pCACert := #pActConn^.szCACertPEMFilename[0];
                end_if;
                if pActConn^.szClientCertChainPEMFilename[0] <> 0x00 then
                  pClientCertChain := #pActConn^.szClientCertChainPEMFilename[0];
                end_if;
                if pActConn^.szClientCertKeyPEMFilename[0] <> 0x00 then
                  pClientCertKey := #pActConn^.szClientCertKeyPEMFilename[0];
                end_if;
                if pActConn^.szKeyDecryptPwd[0] <> 0x00 then
                  pDecryptPass := #pActConn^.szKeyDecryptPwd[0];
                end_if;
                
                pActConn^.dSocket := OS_SSL_USER_CREATE_CONN_STRUCT(pCACert,//#pActConn^.szCACertPEMFilename[0],
                                                                    pClientCertChain,//#pActConn^.szClientCertChainPEMFilename[0],
                                                                    pClientCertKey,//#pActConn^.szClientCertKeyPEMFilename[0],
                                                                    pDecryptPass,//#pActConn^.szKeyDecryptPwd[0],
                                                                    nil);
              end_if;

              if (pActConn^.dSocket < 0) then
                ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_OS, pActConn^.dSocket);
                pActConn^.FSM_TCP := _STATE_ERROR;
              else
                if (pActConn^.bdSettings.ConnSSL = false) then
                  pActConn^.FSM_TCP := _STATE_MAIN_SOCK_OPT;
                else
                  pActConn^.FSM_TCP := _STATE_CONNECT;
                end_if;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_MAIN_SOCK_OPT: // set socket options
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
            else
              dRet := SetSocketOptions((pActConn)$DINT);
              if (dRet = TCPCLT_ERROR_NO) then
                pActConn^.FSM_TCP := _STATE_CONNECT;
              else
                pActConn^.FSM_TCP := _STATE_SHUTDOWN;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_CONNECT: // connect
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
            else
              if (_strlen(#pActConn^.szIPAddress[0])) & ((ops.tAbsolute - pActConn^.udTimeStamp) > pActConn^.udTimeout) then 

                if (pActConn^.bdSettings.ConnSSL = false) then
                  dRet := OS_TCP_USER_CONNECT(pActConn^.dSocket, 0, #pActConn^.szIPAddress[0], TO_UDINT(Port), 0);
                else
                  dRet := OS_SSL_USER_CONNECT(pActConn^.dSocket, #pActConn^.szIPAddress[0], TO_UDINT(Port), 0);
                end_if;

                pActConn^.udTimeStamp := 0;

                if (dRet < 0) then
                  if (dRet <> TCP_NOT_READY) then
                    ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_OS, dRet);
                    pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
                    pActConn^.udTimeStamp := ops.tAbsolute;
                  end_if;
                elsif (dRet = 0) then
                  pActConn^.FSM_TCP := _STATE_RECV;
                  pActConn^.bConnected := true;
                  ConnInfoCallback(pActConn, TCP_CLT_INFO_CONNECT, 0);
                end_if;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_CONN_SOCK_OPT: // set socket options
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
            else
              dRet := SetSocketOptions((pActConn)$DINT);
              if (dRet = TCPCLT_ERROR_NO) then
                pActConn^.FSM_TCP := _STATE_RECV;
              else
                pActConn^.FSM_TCP := _STATE_SHUTDOWN;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_RECV: // receive state
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
            elsif (pActConn^.bdSettings.ConnSSL = false) & (pActConn^.bdSettings.SockOptChanged = true) then
              pActConn^.FSM_TCP := _STATE_CONN_SOCK_OPT;
            else
              dBytes := AP_NReadAvailable(pActConn);
              if (dBytes <= 0) then
                if (dBytes <> TCP_NOT_READY) then
                  ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_OS, dBytes);
                  pActConn^.FSM_TCP := _STATE_SHUTDOWN;
                else
                  if (pActConn^.udTimeout) & (pActConn^.udTimeStamp) then
                    if ((ops.tAbsolute - pActConn^.udTimeStamp) > pActConn^.udTimeout) then
                      pActConn^.udTimeStamp := 0;
                      ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_AP, TCP_CLT_ERR_CODE_AP_TIMEOUT);
                      pActConn^.FSM_TCP := _STATE_SHUTDOWN;
                    end_if;
                  end_if;
                end_if;
                
                pActConn^.pCallbackThis$^_TCPIPClientInterface^.DataHandling(udAvailableData:=0);
                
              else
                if (dBytes$UDINT > SizeOfTXBuffer) then
                  dBytes$UDINT := SizeOfTXBuffer;
                end_if;
                
                
                UserDataToRead := pActConn^.pCallbackThis$^_TCPIPClientInterface^.DataHandling(udAvailableData:=to_udint(dBytes));
                
                if UserDataToRead > to_udint(dBytes) then
                  UserDataToRead := to_udint(dBytes);
                end_if;
                
                if UserDataToRead > 0 then
                  dBytes := to_dint(UserDataToRead);
                
                  if (pActConn^.bdSettings.ConnSSL = false) then
                    dRet := OS_TCP_USER_RECV(pActConn^.dSocket, pActConn^.pSendReceiveBuffer, to_UDINT(dBytes), 0, 0);
                  else
                    dRet := OS_SSL_USER_READ(pActConn^.dSocket, pActConn^.pSendReceiveBuffer, dBytes, 0);
                    if (dRet > 0) then
                      dBytes := dRet;
                    end_if;
                  end_if;

                  if (dRet = dBytes) then
                    pActConn^.pCallbackThis$^_TCPIPClientInterface^.Response(pData:=pActConn^.pSendReceiveBuffer, udsize:=dBytes$UDINT);
                    pActConn^.udTimeStamp := 0;
                  else
                    if (dRet <> TCP_NOT_READY) then
                      ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_OS, dRet);
                      pActConn^.FSM_TCP := _STATE_SHUTDOWN;
                    end_if;
                  end_if;
                end_if;
                
              end_if;

              if (pActConn^.FSM_TCP = _STATE_RECV) then
                if (pActConn^.RingbufferForSending.udUsed > sizeof(pActConn^.BufferHeader.DataSize)) then
                  pActConn^.FSM_TCP := _STATE_SEND;
                end_if;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_SEND: // send data
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
            else
              if (pActConn^.BufferHeader.DataSize = 0) then
                dRet := RingbufferReadEntry(#pActConn^.RingbufferForSending, pActConn^.pSendReceiveBuffer, #pActConn^.BufferHeader.DataSize);
                pActConn^.pSendReceiveBufferHelp := pActConn^.pSendReceiveBuffer;
              end_if;
              if (pActConn^.BufferHeader.DataSize > 0) then
                if (pActConn^.bdSettings.ConnSSL = false) then
                  dRet := OS_TCP_USER_SEND(pActConn^.dSocket, pActConn^.pSendReceiveBufferHelp, pActConn^.BufferHeader.DataSize, 0, 0);
                else
                  dRet := OS_SSL_USER_WRITE(pActConn^.dSocket, pActConn^.pSendReceiveBufferHelp, (pActConn^.BufferHeader.DataSize)$DINT, 0);
                end_if;

                if dRet >= 0 then
                  pActConn^.BufferHeader.DataSize -= dRet$UDINT;
                  pActConn^.pSendReceiveBufferHelp += dRet;
                  pActConn^.udTimeStamp := ops.tAbsolute;
                else
                  if (dRet <> TCP_NOT_READY) then
                    ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_OS, dRet);
                    pActConn^.FSM_TCP := _STATE_SHUTDOWN;
                  else 
                    if (pActConn^.udTimeout) & (pActConn^.udTimeStamp) then
                      if (ops.tAbsolute - pActConn^.udTimeStamp) >= pActConn^.udTimeout then
                        ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_AP, TCP_CLT_ERR_CODE_AP_TIMEOUT);
                        pActConn^.FSM_TCP := _STATE_SHUTDOWN;
                        pActConn^.udTimeStamp := 0;
                      end_if;
                    end_if;
                  end_if;
                end_if;

                if pActConn^.BufferHeader.DataSize <= 0 then
                  pActConn^.FSM_TCP := _STATE_RECV;
                  pActConn^.pSendReceiveBufferHelp := pActConn^.pSendReceiveBuffer;
                else
                  bdStatus.InhibNextConn := true;
                end_if;
              else
                pActConn^.FSM_TCP := _STATE_RECV;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_SHUTDOWN: // disable receives and sends on socket
          //****************************************************************************
            if (pActConn^.bdSettings.ConnSSL = false) then
              OS_TCP_USER_SHUTDOWN(pActConn^.dSocket, 2);
            end_if;
            pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;

          //****************************************************************************
          _STATE_CLOSE_MAIN_SOCK: // close socket
          //****************************************************************************
            if (pActConn^.bdSettings.ConnSSL = false) then
              OS_TCP_USER_CLOSESOCKET(pActConn^.dSocket, pActConn^.CloseSocketType);
            else
              OS_SSL_USER_FREE_CONN(pActConn^.dSocket);
            end_if;
            pActConn^.dSocket := 0;
            pActConn^.bConnected := false;
            ConnInfoCallback(pActConn, TCP_CLT_INFO_DISCONNECT, 0);
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_DEL_CONNECTION;
            else
              pActConn^.FSM_TCP := _STATE_IDLE;
            end_if;

          //****************************************************************************
          _STATE_DEL_CONNECTION: // delete connection
          //****************************************************************************
            DelConnIntern(pActConn);

          //****************************************************************************
          _STATE_ERROR,
          _STATE_ERROR_ALLOCATING_MEMORY,
          _STATE_ERROR_CREATING_MUTEX,
          _STATE_ERROR_CREATING_TASK: 
          //****************************************************************************

          //****************************************************************************
          else // - INVALID STATE
          //****************************************************************************
            TRACE("Fatal Error");
            pActConn^.FSM_TCP := _STATE_ERROR;

        end_case;      

        if (ActConn = 0) then
          pActConn := NIL;
          Control   := _STATE_IDLE;
          FSMClient := _STATE_INIT;
        else
          if (bdStatus.InhibNextConn = false) then
            pActConn := pActConn^.pNextConn;
            Control  := pActConn^.FSM_TCP;
          end_if;
          bdStatus.InhibNextConn := false;
        end_if;

  end_case;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClient::AddConnection
	VAR_INPUT
		pIPAddress 	: ^CHAR;
		pCallbackThis 	: ^_TCPIPClientInterface;
		udTimeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dHandle 	: DINT;
	END_VAR
VAR
	dRet            : DINT;
END_VAR

  dHandle := 0;

  if (usInit > 0) then
    if (bdStatus.CIL_tcp_user = true) then
      if (bdStatus.ErrMem = false) then
        dRet := CheckParaConnTCP(pIPAddress, pCallbackThis);
        if (dRet = TCP_CLT_NO_ERROR) then

          dHandle := AddConnIntern(pIPAddress,
                                   NIL,
                                   NIL,
                                   NIL,
                                   NIL,
                                   pCallbackThis,
                                   udTimeout,
                                   false);

        else
          LastError := dRet;
        end_if;
      else
        LastError := TCP_CLT_ERR_CONN_MEMORY;
      end_if;
    else
      LastError := TCP_CLT_ERR_NO_TCP_INTERFACE;
    end_if;
  else
    LastError := TCP_CLT_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClient::AddConnectionSSL
	VAR_INPUT
		pIPAddress 	: ^CHAR;
		pCACertPEMFilename 	: ^CHAR;
		pClientCertChainPEMFilename 	: ^CHAR;
		pClientCertKeyPEMFilename 	: ^CHAR;
		pKeyDecryptPwd 	: ^CHAR;
		pCallbackThis 	: ^_TCPIPClientInterface;
		udTimeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dHandle 	: DINT;
	END_VAR
VAR
	dRet                          : DINT;
END_VAR

  dHandle := 0;

  if (usInit > 0) then
    if (bdStatus.CIL_ssl_user = true) then
      if (bdStatus.ErrMem = false) then
        dRet := CheckParaConnSSL(pCACertPEMFilename, pClientCertChainPEMFilename, pClientCertKeyPEMFilename, pKeyDecryptPwd);
        if (dRet = TCP_CLT_NO_ERROR) then
          dRet := CheckParaConnTCP(pIPAddress, pCallbackThis);
          if (dRet = TCP_CLT_NO_ERROR) then

            dHandle := AddConnIntern(pIPAddress,
                                     pCACertPEMFilename,
                                     pClientCertChainPEMFilename,
                                     pClientCertKeyPEMFilename,
                                     pKeyDecryptPwd,
                                     pCallbackThis,
                                     udTimeout,
                                     true);

          else
            LastError := dRet;
          end_if;
        else
          LastError := dRet;
        end_if;
      else
        LastError := TCP_CLT_ERR_CONN_MEMORY;
      end_if;
    else
      LastError := TCP_CLT_ERR_NO_SSL_INTERFACE;
    end_if;
  else
    LastError := TCP_CLT_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClient::IsConnected
	VAR_INPUT
		dHandle 	: DINT;
	END_VAR
	VAR_OUTPUT
		bRetcode 	: BOOL;
	END_VAR

  bRetcode := false;

  if (CheckHandleValid(dHandle := dHandle) = true) then
    bRetcode := dHandle$^_CONNECTION^.bConnected;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClient::SendData
	VAR_INPUT
		pData 	: ^void;
		udSize 	: UDINT;
		dHandle 	: DINT;
		bDirect 	: BOOL;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
VAR
  dRet            : DINT;
  pConn           : ^_CONNECTION;
END_VAR  

  dRetcode := TCP_CLT_SEND_FAILED;

  if (CheckHandleValid(dHandle) = true) then
    pConn := dHandle$^_CONNECTION;
    if (pConn^.bConnected = true) then
      if (bDirect = true) then
        if (udSize <= 1452) then
          if pConn^.bdSettings.ConnSSL then // HubChr v1.1 - use SSL-Send Method for SSL-Connections
            dRet := SendSSL(pConn, pData$^CHAR, udSize, 0);
          else
            dRet := SendTCP(pConn, pData$^CHAR, udSize, 0);
          end_if;
          if (dRet = to_DINT(udSize)) then
            dRetcode := TCP_CLT_SEND_OK;
          end_if;
        else
          dRetcode := TCP_CLT_DATA_TO_BIG_FOR_DIRECT_SENDING;
        end_if;
      else
        dRet := RingbufferWriteEntry(#pConn^.RingbufferForSending, pData, udSize);
        if (dRet = TCP_CLT_NO_ERROR) then
          dRetcode := TCP_CLT_SEND_OK;
        else
          dRetcode := dRet;
        end_if;
      end_if;
    else
      dRetcode := TCP_CLT_NOT_CONNECTED;
    end_if;
  else
    dRetcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClient::DelConnection
	VAR_INPUT
		dHandle 	: DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (usInit > 0) then
    if (CheckHandleValid(dHandle := dHandle) = true) then
      dHandle$^_CONNECTION^.bdSettings.DelConn := true;
    else
      Retcode   := TCP_CLT_INVALID_HANDLE;
    end_if;
  else
    Retcode   := TCP_CLT_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClient::FLUSHRingbuffer
	VAR_INPUT
		dHandle 	: DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR
VAR
	pBuffer   : ^_TX_RINGBUFFER;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (usInit > 0) then
    if (CheckHandleValid(dHandle := dHandle) = true) then
      AP_SemaWait(AP_SemaHandle1);
      pBuffer := #dHandle$^_CONNECTION^.RingbufferForSending;
      pBuffer^.pRead := pBuffer^.pMem;
      pBuffer^.pWrite := pBuffer^.pMem;
      pBuffer^.udUsed := 0;
      AP_SemaSignal(AP_SemaHandle1);
    else
      Retcode := TCP_CLT_INVALID_HANDLE;
    end_if;
  else
    Retcode := TCP_CLT_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClient::SetConnParameter
	VAR_INPUT
		dHandle 	: DINT;
		Cmd 	: DINT;
		SubCmd 	: DINT;
		ParaValue 	: DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR
VAR
  pConn           : ^_CONNECTION;
END_VAR

  Retcode := TCPCLT_ERROR_NO;

  if (CheckHandleValid(dHandle) = true) then
    pConn := dHandle$^_CONNECTION;
    case Cmd of
      (*================================================================*)
      CLT_TCP_CMD_SETSOCKOPT:
      (*================================================================*)
        if (pConn^.bdSettings.ConnSSL = true) then
          Retcode := TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED;
        else
          case SubCmd of
            (*==================================================*)
            CLT_TCP_SOCKOPT_NAGLE:
            (*==================================================*)
              if (ParaValue = 0) then
                if (pConn^.ConnSockOpt.Nagle = true) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.Nagle := false;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              else
                if (pConn^.ConnSockOpt.Nagle = false) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.Nagle := true;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              end_if;
            (*==================================================*)
            CLT_TCP_SOCKOPT_KEEPALIVE:
            (*==================================================*)
              if (ParaValue = 0) then
                if (pConn^.ConnSockOpt.KeepAlive = true) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.KeepAlive := false;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              else
                if (pConn^.ConnSockOpt.KeepAlive = false) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.KeepAlive := true;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              end_if;
            (*==================================================*)
            CLT_TCP_SOCKOPT_DELAYEDACK:
            (*==================================================*)
              if (ParaValue = 0) then
                if (pConn^.ConnSockOpt.DelayedAck = true) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.DelayedAck := false;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              else
                if (pConn^.ConnSockOpt.DelayedAck = false) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.DelayedAck := true;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              end_if;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;
        end_if;

      (*================================================================*)
      CLT_TCP_CMD_KEEPALIVEPARA:
      (*================================================================*)
        if (pConn^.bdSettings.ConnSSL = true) then
          Retcode := TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED;
        else
          case SubCmd of
            (*==================================================*)
            CLT_TCP_KEEPALIVE_KEEPIDLE:
            (*==================================================*)
              AP_SemaWait(AP_SemaSockOpt);
              pConn^.KeepAlivePara.keepIDLE    := ParaValue;
              pConn^.bdSettings.SockOptChanged := true;
              AP_SemaSignal(AP_SemaSockOpt);
            (*==================================================*)
            CLT_TCP_KEEPALIVE_KEEPINTVL:
            (*==================================================*)
              AP_SemaWait(AP_SemaSockOpt);
              pConn^.KeepAlivePara.keepINTVL   := ParaValue;
              pConn^.bdSettings.SockOptChanged := true;
              AP_SemaSignal(AP_SemaSockOpt);
            (*==================================================*)
            CLT_TCP_KEEPALIVE_KEEPCNT:
            (*==================================================*)
              AP_SemaWait(AP_SemaSockOpt);
              pConn^.KeepAlivePara.keepCNT     := ParaValue;
              pConn^.bdSettings.SockOptChanged := true;
              AP_SemaSignal(AP_SemaSockOpt);
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;
        end_if;

      (*================================================================*)
      CLT_TCP_CMD_CLOSESOCKETTYPE:
      (*================================================================*)
        if (pConn^.bdSettings.ConnSSL = true) then
          Retcode := TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED;
        else
          case SubCmd of
            (*==================================================*)
            CLT_TCP_CLOSESOCKETTYPE:
            (*==================================================*)
              pConn^.CloseSocketType := ParaValue$UDINT;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;
        end_if;

      (*================================================================*)
      else // - INVALID COMMAND
      (*================================================================*)
        Retcode := TCP_CLT_ERR_SET_PARA_INVALID_CMD;

    end_case;
  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClient::ReadConnParameter
	VAR_INPUT
		dHandle 	: DINT;
		Cmd 	: DINT;
		SubCmd 	: DINT;
		pParaValue 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR
VAR
	pConn       : ^_CONNECTION;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (CheckHandleValid(dHandle) = true) then
    pConn := dHandle$^_CONNECTION;
    case Cmd of
      (*================================================================*)
      CLT_TCP_CMD_SETSOCKOPT:
      (*================================================================*)
        if (pConn^.bdSettings.ConnSSL = true) then
          Retcode := TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED;
        else
          case SubCmd of
            (*==================================================*)
            CLT_TCP_SOCKOPT_NAGLE:
            (*==================================================*)
              if (pConn^.ConnSockOpt.Nagle = false) then
                pParaValue^ := 0;
              else
                pParaValue^ := 1;
              end_if;
            (*==================================================*)
            CLT_TCP_SOCKOPT_KEEPALIVE:
            (*==================================================*)
              if (pConn^.ConnSockOpt.KeepAlive = false) then
                pParaValue^ := 0;
              else
                pParaValue^ := 1;
              end_if;
            (*==================================================*)
            CLT_TCP_SOCKOPT_DELAYEDACK:
            (*==================================================*)
              if (pConn^.ConnSockOpt.DelayedAck = false) then
                pParaValue^ := 0;
              else
                pParaValue^ := 1;
              end_if;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;
        end_if;

      (*================================================================*)
      CLT_TCP_CMD_KEEPALIVEPARA:
      (*================================================================*)
        if (pConn^.bdSettings.ConnSSL = true) then
          Retcode := TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED;
        else
          case SubCmd of
            (*==================================================*)
            CLT_TCP_KEEPALIVE_KEEPIDLE:
            (*==================================================*)
              pParaValue^ := pConn^.KeepAlivePara.keepIDLE;
            (*==================================================*)
            CLT_TCP_KEEPALIVE_KEEPINTVL:
            (*==================================================*)
              pParaValue^ := pConn^.KeepAlivePara.keepINTVL;
            (*==================================================*)
            CLT_TCP_KEEPALIVE_KEEPCNT:
            (*==================================================*)
              pParaValue^ := pConn^.KeepAlivePara.keepCNT;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;
        end_if;

      (*================================================================*)
      CLT_TCP_CMD_CLOSESOCKETTYPE:
      (*================================================================*)
        if (pConn^.bdSettings.ConnSSL = true) then
          Retcode := TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED;
        else
          case SubCmd of
            (*==================================================*)
            CLT_TCP_CLOSESOCKETTYPE:
            (*==================================================*)
              pParaValue^$UDINT := pConn^.CloseSocketType;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;
        end_if;

      (*================================================================*)
      else // - INVALID COMMAND
      (*================================================================*)
        Retcode := TCP_CLT_ERR_SET_PARA_INVALID_CMD;

    end_case;
  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClient::SetMainParameter
	VAR_INPUT
		Cmd 	: DINT;
		SubCmd 	: DINT;
		ParaValue 	: DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (usInit > 0) then
    case Cmd of
      (*================================================================*)
      CLT_TCP_CMD_SETSOCKOPT:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          CLT_TCP_SOCKOPT_NAGLE:
          (*==================================================*)
            if (ParaValue = 0) then
              MainSockOpt.Nagle := false;
            else
              MainSockOpt.Nagle := true;
            end_if;
          (*==================================================*)
          CLT_TCP_SOCKOPT_KEEPALIVE:
          (*==================================================*)
            if (ParaValue = 0) then
              MainSockOpt.KeepAlive := false;
            else
              MainSockOpt.KeepAlive := true;
            end_if; 
          (*==================================================*)
          CLT_TCP_SOCKOPT_DELAYEDACK:
          (*==================================================*)
            if (ParaValue = 0) then
              MainSockOpt.DelayedAck := false;
            else
              MainSockOpt.DelayedAck := true;
            end_if;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      CLT_TCP_CMD_TASKPRIO:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          CLT_TCP_SUB_CMD_TASKPRIO:
          (*==================================================*)
            if (usInit < INIT_FIRSTSCAN) then
              AP_TaskPriority := ParaValue$UDINT;
            else
              Retcode := TCP_CLT_ERR_TASK_ALREADY_EXIST;
            end_if;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      CLT_TCP_CMD_KEEPALIVEPARA:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          CLT_TCP_KEEPALIVE_KEEPIDLE:
          (*==================================================*)
            KeepAlivePara.keepIDLE := ParaValue;
          (*==================================================*)
          CLT_TCP_KEEPALIVE_KEEPINTVL:
          (*==================================================*)
            KeepAlivePara.keepINTVL := ParaValue;
          (*==================================================*)
          CLT_TCP_KEEPALIVE_KEEPCNT:
          (*==================================================*)
            KeepAlivePara.keepCNT := ParaValue;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      CLT_TCP_CMD_CLOSESOCKETTYPE:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          CLT_TCP_CLOSESOCKETTYPE:
          (*==================================================*)
            CloseSocketType := ParaValue$UDINT;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      else // - INVALID COMMAND
      (*================================================================*)
        Retcode := TCP_CLT_ERR_SET_PARA_INVALID_CMD;

    end_case;
  else
    Retcode := TCP_CLT_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClient::ReadMainParameter
	VAR_INPUT
		Cmd 	: DINT;
		SubCmd 	: DINT;
		pParaValue 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (usInit > 0) then
    case Cmd of
      (*================================================================*)
      CLT_TCP_CMD_SETSOCKOPT:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          CLT_TCP_SOCKOPT_NAGLE:
          (*==================================================*)
            if (MainSockOpt.Nagle = false) then
              pParaValue^ := 0;
            else
              pParaValue^ := 1;
            end_if;
          (*==================================================*)
          CLT_TCP_SOCKOPT_KEEPALIVE:
          (*==================================================*)
            if (MainSockOpt.KeepAlive = false) then
              pParaValue^ := 0;
            else
              pParaValue^ := 1;
            end_if; 
          (*==================================================*)
          CLT_TCP_SOCKOPT_DELAYEDACK:
          (*==================================================*)
            if (MainSockOpt.DelayedAck = false) then
              pParaValue^ := 0;
            else
              pParaValue^ := 1;
            end_if;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      CLT_TCP_CMD_TASKPRIO:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          CLT_TCP_SUB_CMD_TASKPRIO:
          (*==================================================*)
            pParaValue^ := AP_TaskPriority$DINT;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      CLT_TCP_CMD_KEEPALIVEPARA:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          CLT_TCP_KEEPALIVE_KEEPIDLE:
          (*==================================================*)
            pParaValue^ := KeepAlivePara.keepIDLE;
          (*==================================================*)
          CLT_TCP_KEEPALIVE_KEEPINTVL:
          (*==================================================*)
            pParaValue^ := KeepAlivePara.keepINTVL;
          (*==================================================*)
          CLT_TCP_KEEPALIVE_KEEPCNT:
          (*==================================================*)
            pParaValue^ := KeepAlivePara.keepCNT;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      CLT_TCP_CMD_CLOSESOCKETTYPE:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          CLT_TCP_CLOSESOCKETTYPE:
          (*==================================================*)
            pParaValue^$UDINT := CloseSocketType;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      else // - INVALID COMMAND
      (*================================================================*)
        Retcode := TCP_CLT_ERR_SET_PARA_INVALID_CMD;

    end_case;
  else
    Retcode := TCP_CLT_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIPClient::GetSetting
	VAR_INPUT
		Index 	: DINT;
		pSetting 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := 0;

  case Index of

    (*============================================================================*)
    CLT_TCP_GET_SETTING_PORT:
    (*============================================================================*)
      pSetting^ := Port;

    (*============================================================================*)
    CLT_TCP_GET_SETTING_BUFSIZE:
    (*============================================================================*)
      pSetting^ := SizeOfTXBuffer$DINT;

    (*============================================================================*)
    CLT_TCP_GET_SETTING_MAXCONN:
    (*============================================================================*)
      pSetting^ := MaxConnections;

    (*============================================================================*)
    CLT_TCP_GET_SETTING_CONFIG:
    (*============================================================================*)
      pSetting^ := Config;

    (*============================================================================*)
    else
    (*============================================================================*)
      Retcode := -1;

  end_case;

END_FUNCTION

FUNCTION GLOBAL _TCPIPClient::GetLastError
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := LastError;

END_FUNCTION

FUNCTION _TCPIPClient::RingbufferReadEntry
	VAR_INPUT
		pBuffer 	: ^_TX_RINGBUFFER;
		pData 	: ^void;
		pSize 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR
VAR
	BufferHeader    : _BUFFER_HEADER;
  dRet            : DINT;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;
  pSize^  := 0;

  if (pBuffer = NIL) | (pData = NIL) | (pSize = NIL) then
    Retcode := TCP_CLT_ERR_INVALID_POINTER;
  else
    if (pBuffer^.udUsed = 0) then
      Retcode := TCP_CLT_SEND_BUFFER_EMPTY;
    else
      AP_SemaWait(AP_SemaHandle1);
      dRet := RingbufferRead(pBuffer, #BufferHeader, sizeof(_BUFFER_HEADER));
      if (dRet = sizeof(_BUFFER_HEADER)) then
        dRet := RingbufferRead(pBuffer, pData, BufferHeader.DataSize);
        if (dRet = BufferHeader.DataSize$DINT) then
          pSize^ := BufferHeader.DataSize;
        else
          Retcode := TCP_CLT_ERR_SEND_BUFFER_FATAL_ERROR;
        end_if;
      else
        Retcode := TCP_CLT_ERR_SEND_BUFFER_FATAL_ERROR;
      end_if;
      AP_SemaSignal(AP_SemaHandle1);
    end_if;
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::RingbufferRead
	VAR_INPUT
		pBuffer 	: ^_TX_RINGBUFFER;
		pData 	: ^void;
		udSize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
VAR
	udBytes2End   : UDINT;
  udBytesTmp    : UDINT;
END_VAR

  dRetcode := 0;

  if (pBuffer = NIL) | (pData = NIL) | (pBuffer^.pMem = NIL) then
    return; //### invalid pointer
  end_if;

  udBytes2End := (pBuffer^.pMem$UDINT + pBuffer^.udSize) - pBuffer^.pRead$UDINT;

  if (udSize > udBytes2End) then 

    //##########################################################################################
    //### we must read the data in 2 blocks (|second|...........other data...........|first|)
    //##########################################################################################
    _memcpy(ptr1 := pData, ptr2 := pBuffer^.pRead, cntr := udBytes2End); //### copy the first block
    pData += udBytes2End;
    pBuffer^.pRead := pBuffer^.pMem$^USINT;
    udBytesTmp := udSize - udBytes2End;
    _memcpy(ptr1 := pData, ptr2 := pBuffer^.pRead, cntr := udBytesTmp); //### copy the second block
    pBuffer^.pRead += udBytesTmp;

  else

    //##########################################################################################
    //### read data in one block
    //##########################################################################################
    _memcpy(ptr1 := pData, ptr2 := pBuffer^.pRead, cntr := udSize);
    pBuffer^.pRead += udSize;
  end_if;

  pBuffer^.udUsed -= udSize; // decrease the number of bytes in ringbuffer
  dRetcode := udSize$DINT;

END_FUNCTION

FUNCTION _TCPIPClient::RingbufferWriteEntry
	VAR_INPUT
		pBuffer 	: ^_TX_RINGBUFFER;
		pData 	: ^void;
		udSize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR
VAR
	BufferHeader  : _BUFFER_HEADER;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (pBuffer = NIL) | (pData = NIL) then
    Retcode := TCP_CLT_ERR_INVALID_POINTER;
  else
    AP_SemaWait(AP_SemaHandle1);
    if ((udSize + sizeof(_BUFFER_HEADER)) > (pBuffer^.udSize - pBuffer^.udUsed)) then
      Retcode := TCP_CLT_SEND_BUFFER_FULL;
    else
      BufferHeader.DataSize := udSize;
      RingbufferWrite(pBuffer, #BufferHeader, sizeof(_BUFFER_HEADER));
      RingbufferWrite(pBuffer, pData, udSize);
    end_if;
    AP_SemaSignal(AP_SemaHandle1);
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::RingbufferWrite
	VAR_INPUT
		pBuffer 	: ^_TX_RINGBUFFER;
		pData 	: ^void;
		udSize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
VAR
	udBytes2End   : UDINT;
  udBytesTmp    : UDINT;
END_VAR

  dRetcode := 0;

  if (pBuffer = NIL) | (pData = NIL) | (pBuffer^.pMem = NIL) then
    return; //### invalid pointer
  end_if;

  if ((udSize) > (pBuffer^.udSize - pBuffer^.udUsed)) then
    return; //### buffer full
  end_if;

  udBytes2End := (pBuffer^.pMem$UDINT + pBuffer^.udSize) - pBuffer^.pWrite$UDINT; // calculate number of bytes till the end of SENDbuffer

  if (udSize > udBytes2End) then
    
    //##########################################################################################
    //### we must write the data in 2 blocks  (|second|...........other data...........|first|)
    //##########################################################################################
    _memcpy(ptr1 := pBuffer^.pWrite, ptr2 := pData, cntr := udBytes2End); // copy the first block
    pData += udBytes2End;
    pBuffer^.pWrite := pBuffer^.pMem$^USINT;
    udBytesTmp := udSize - udBytes2End;
    _memcpy(ptr1 := pBuffer^.pWrite, ptr2 := pData, cntr := udBytesTmp); // copy the second block
    pBuffer^.pWrite += udBytesTmp;
  else
    
    //##########################################################################################
    //### store data in one block
    //##########################################################################################
    _memcpy(ptr1 := pBuffer^.pWrite, ptr2 := pData, cntr := udSize);
    pBuffer^.pWrite += udSize;
  end_if;
  
  pBuffer^.udUsed += udSize; // increase the number of bytes in ringbuffer
  dRetcode := udSize$DINT;

END_FUNCTION

FUNCTION _TCPIPClient::CheckHandleValid
	VAR_INPUT
		dHandle 	: DINT;
	END_VAR
	VAR_OUTPUT
		bRetcode 	: BOOL;
	END_VAR
VAR
	i         : USINT;
  pConn     : ^_CONNECTION;
END_VAR

  bRetcode := false;

  if (dHandle <> 0) then
    AP_SemaWait(AP_SemaHandle1);
    for i := 0 to (MaxConn-1) do
      pConn := pConnectionBuffer + (i * sizeof(_CONNECTION));
      if (pConn = dHandle$^_CONNECTION) then
        if (pConn^.bInUse = true) & (pConn^.bdSettings.DelConn = false) then
          bRetcode := true;
          exit;
        end_if;
      end_if;
    end_for;
    AP_SemaSignal(AP_SemaHandle1);
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::SendTCP
	VAR_INPUT
		pConnection 	: ^_CONNECTION;
		pData 	: ^CHAR;
		udSize 	: UDINT;
		udTimeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR

  dRetcode := OS_TCP_USER_SEND(pConnection^.dSocket,
                               pData,
                               udSize,
                               0, //### flags ... not used
                               udTimeout
                               );

  if (dRetcode = udSize$DINT) then
    pConnection^.udTimeStamp := ops.tAbsolute;
  else
    udSendError += 1;
    pConnection^.FSM_TCP := _STATE_SHUTDOWN;
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::SetSocketOptions
	VAR_INPUT
		dHandle 	: DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR
VAR
	OptionValue       : DINT;
  pConn             : ^_CONNECTION;
  dRet              : DINT;
  KeepAliveLasalOS  : _KeepAliveParaLasalOS;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (CheckHandleValid(dHandle) = true) then

    pConn := dHandle$^_CONNECTION;

    AP_SemaWait(AP_SemaSockOpt);

    // -----------------------------------------------------------
    // - SOCKET OPTION NAGLE
    // -----------------------------------------------------------
    if (pConn^.ConnSockOpt.Nagle = true) then
      OptionValue := 1;
    else
      OptionValue := 0;
    end_if;
    dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_SOCKET, SO_NAGLE, (#OptionValue)$^CHAR, sizeof(DINT));
    if (dRet < 0) then
      Retcode := dRet;
      ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
    end_if;

    // -----------------------------------------------------------
    // - SOCKET OPTION KEEP ALIVE
    // -----------------------------------------------------------
    if (bdStatus.SalamanderOS = false) then
      // --------------------------------------------------------
      // - LASAL OS
      // --------------------------------------------------------
      if (pConn^.ConnSockOpt.KeepAlive = true) then
        KeepAliveLasalOS.interval := to_UINT(pConn^.KeepAlivePara.keepIDLE);
        KeepAliveLasalOS.retry    := to_UINT(pConn^.KeepAlivePara.keepINTVL);
        KeepAliveLasalOS.timeout  := to_UINT(pConn^.KeepAlivePara.keepCNT * pConn^.KeepAlivePara.keepINTVL);
      else
        KeepAliveLasalOS.interval := 0;
        KeepAliveLasalOS.retry    := 0;
        KeepAliveLasalOS.timeout  := 0;
      end_if;
      dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_SOCKET, 8, (#KeepAliveLasalOS)$^CHAR, sizeof(_KeepAliveParaLasalOS));
      if (dRet < 0) then
        Retcode := dRet;
        ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
      end_if;
    else
      // --------------------------------------------------------
      // - SALAMANDER OS
      // --------------------------------------------------------
      if (pConn^.ConnSockOpt.KeepAlive = true) then
        OptionValue := 1;
      else
        OptionValue := 0;
      end_if;
      dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_SOCKET, 8, (#OptionValue)$^CHAR, sizeof(DINT));
      if (dRet < 0) then
        Retcode := dRet;
        ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
      end_if;

//      if (pConn^.ConnSockOpt.KeepAlive = true) then
//        OptionValue := KeepAlivePara.keepCNT;
//        dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_TCP, TCP_KEEPCNT, (#OptionValue)$^CHAR, sizeof(DINT));
//        if (dRet < 0) then
//          Retcode := dRet;
//          ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
//        end_if;
//        OptionValue := KeepAlivePara.keepIDLE;
//        dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_TCP, TCP_KEEPIDLE, (#OptionValue)$^CHAR, sizeof(DINT));
//        if (dRet < 0) then
//          Retcode := dRet;
//          ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
//        end_if;
//        OptionValue := KeepAlivePara.keepINTVL;
//        dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_TCP, TCP_KEEPINTVL, (#OptionValue)$^CHAR, sizeof(DINT));
//        if (dRet < 0) then
//          Retcode := dRet;
//          ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
//        end_if;
//      end_if;
    end_if;

    // -----------------------------------------------------------
    // - SOCKET OPTION DELAYED ACK
    // -----------------------------------------------------------
    if (pConn^.ConnSockOpt.DelayedAck = true) then
      OptionValue := 1;
    else
      OptionValue := 0;
    end_if;
    dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_SOCKET, SO_DELAYED_ACK, (#OptionValue)$^CHAR, sizeof(DINT));
    if (dRet < 0) then
      Retcode := dRet;
      ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
    end_if;

    pConn^.bdSettings.SockOptChanged := false;

    AP_SemaSignal(AP_SemaSockOpt);

  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::Read_LSLOBJ_CRC32
	VAR_INPUT
		pCRC32 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR
VAR
	udStrLen    : UDINT;
  udCRC32     : UDINT;
  szObjName   : ARRAY [0..255] OF CHAR;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (pCRC32 <> NIL) then
    pCRC32^ := 0x00;
    udStrLen := _GetObjName(this, #szObjName[0]);
    if (udStrLen > 0) then
      udCRC32 := CheckSum.CRC32(#szObjName[0], udStrLen, 0);
      SigCLib.IToA(udCRC32$DINT, pCRC32, 0x10);
    else
      Retcode := TCP_CLT_ERR_GET_LSLOBJ_NAME;
    end_if;
  else
    Retcode := TCP_CLT_ERR_INVALID_POINTER;
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::Read_AP_TaskPeriod
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR
VAR
	dRet          : DINT;
  LSLOBJ_INFO   : LSLOBJ_INFO;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  dRet := _TaskObjectControl.GetObjectInfo(this, OBJ_CT, #LSLOBJ_INFO);
  case dRet of
    (*=============================================================================*)
    0: // - GET OBJECT INFO OK
    (*=============================================================================*)
      if (bdStatus.SalamanderOS = true) then
        // --------------------------------------------------------
        // - SALAMANDER OS
        // --------------------------------------------------------
        if (LSLOBJ_INFO.orgperiod AND 0x80000000) then
          // -------------------------------------------------------
          // - TASK PERIOD IN [s]
          // -------------------------------------------------------
          AP_TaskTime := LSLOBJ_INFO.orgperiod XOR 0x80000000;
        else
          // -------------------------------------------------------
          // - TASK PERIOD IN [ms]
          // -------------------------------------------------------
          AP_TaskTime := LSLOBJ_INFO.orgperiod * 1000;
        end_if;
      else
        // --------------------------------------------------------
        // - LASAL OS
        // --------------------------------------------------------
        if (LSLOBJ_INFO.orgperiod AND 0x80000000) then
          // -------------------------------------------------------
          // - TASK PERIOD IN [s]
          // -------------------------------------------------------
          AP_TaskTime := (LSLOBJ_INFO.orgperiod XOR 0x80000000) / 1000;
          if (AP_TaskTime = 0) then
            AP_TaskTime := 1;
          end_if;
        else
          // -------------------------------------------------------
          // - TASK PERIOD IN [ms]
          // -------------------------------------------------------
          AP_TaskTime := LSLOBJ_INFO.orgperiod;
        end_if;
      end_if;

    (*=============================================================================*)
    -1: // - ERROR READ OBJECT INFO (NO APPLICATION)
    (*=============================================================================*)
      Retcode     := TCP_CLT_ERR_TASK_TIME_NO_APP;
      AP_TaskTime := 0xFFFFFFFF;

    (*=============================================================================*)
    -3: // - ERROR READ OBJECT INFO (NO APPLICATION)
    (*=============================================================================*)
      Retcode     := TCP_CLT_ERR_TASK_TIME_WRONG_TASK_TYPE;
      AP_TaskTime := 0xFFFFFFFF;

    (*=============================================================================*)
    -5: // - OBJECT NOT FOUND (TASK DEACTIVATED)
    (*=============================================================================*)
      Retcode     := TCP_CLT_ERR_TASK_TIME_OBJ_NOT_FOUND;
      AP_TaskTime := 0xFFFFFFFF;

  end_case;

END_FUNCTION

FUNCTION _TCPIPClient::GetMultiTaskErrorCode
	VAR_INPUT
		pErrTxt 	: ^CHAR;
	END_VAR
VAR
	ErrMT     : DINT;
END_VAR

  ErrMT := _MultiTask.GETLASTERROR();
  case ErrMT of

    (*===============================================================================================*)
    MTERROR_NONE: // - NO ERROR
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_NONE");

    (*===============================================================================================*)
    MTERROR_NOMEM: // - NO MORE MEMORY TO RUN THIS FUNCTION, E.G. INTERNAL ALLOC FAILED
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_NOMEM");

    (*===============================================================================================*)
    MTERROR_NOFCT: // - CREATE TASK NEEDS A VALID TASK FUNCTION
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_NOFCT");

    (*===============================================================================================*)
    MTERROR_FCTNOTINMEM: // - CREATE TASK NEEDS A TASK FUNCTION PLACED IN LASAL CODE MEMORY
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_FCTNOTINMEM");

    (*===============================================================================================*)
    MTERROR_WRONGPRIOR: // - CREATE TASK ONLY SUPPORTS PRIORS FROM 1 .. 14
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_WRONGPRIOR");

    (*===============================================================================================*)
    MTERROR_STACK: // - CREATE TASK ONLY SUPPORT SATCK SIZE LOWER THAN 0x4000
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_STACK");

    (*===============================================================================================*)
    MTERROR_NAME: // - CREATE TASK, MAILBOX OR SEMAPHORE NEEDS A VALID NAME
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_NAME");

    (*===============================================================================================*)
    MTERROR_NAMEUSED: // - CREATE TASK, MAILBOX OR SEMAPHORE NAME ALREADY IN USE
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_NAMEUSED");

    (*===============================================================================================*)
    MTERROR_HANDLE: // - HANDLE NOT FOUND IN OS-LIST => NOT VALID
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_HANDLE");

    (*===============================================================================================*)
    MTERROR_NOTALLOWED: // - MT-FUNCTION NOT ALLOWED IN THIS TASK CONTEXT
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_NOTALLOWED");

    (*===============================================================================================*)
    MTERROR_MESSAGESIZE: // - MAILBOX NEED A VALID MESSAGE SIZE
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_MESSAGESIZE");

    (*===============================================================================================*)
    MTERROR_DATA: // - POINTER TO DATA IS NOT VALID
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_DATA");

    (*===============================================================================================*)
    MTERROR_PTR: // - INVALID POINTER, PARAMETER OR INTERNAL
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_PTR");

    (*===============================================================================================*)
    MTERROR_TASKID: // - INVALID TASK ID, ID NOT FOUND
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_TASKID");

    (*===============================================================================================*)
    MTERROR_NOTASK: // - TASK DOES NOT EXIST
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_NOTASK");

    (*===============================================================================================*)
    MTERROR_NOIFFNC: // - INTERFACE FUNCTION IS NOT AVAILABLE
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_NOIFFNC");

    (*===============================================================================================*)
    else // - UNKNOWN ERROR CODE
    (*===============================================================================================*)
      SigCLib.StrCpy(pErrTxt, "MTERROR_UNKNOWN");

  end_case;

END_FUNCTION

FUNCTION _TCPIPClient::AP_TaskCreate
	VAR_INPUT
		pTaskName 	: ^CHAR;
		pCallback 	: ^void;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  AP_TaskHandle := _MultiTask.CREATETHREAD(pCallback, AP_TaskPriority, 0x4000, MT_TASK_SAVETHIS, this, pTaskName);
  if (AP_TaskHandle = NIL) then
    Retcode := TCP_CLT_ERR_TASK_CREATE;
  end_if;

END_FUNCTION

FUNCTION __CDECL _TCPIPClient::AP_TaskCallback
	VAR_INPUT
		Param0 	: ^void;
	END_VAR

  while 1 do
    CyclicCall();
    AP_TaskDelay(AP_TaskTime);
  end_while;

END_FUNCTION

FUNCTION _TCPIPClient::AP_TaskDelay
	VAR_INPUT
		udTaskDelay 	: UDINT;
	END_VAR

  if (bdStatus.SalamanderOS = true) then
    OSSD_DELAY(pCIL_DEBUG, udTaskDelay);
  else
    _MultiTask.TASKDELAY(udTaskDelay);
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::AP_SemaCreate
	VAR_INPUT
		pSemaName 	: ^CHAR;
		Index 	: DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (pSemaName <> NIL) then
    case Index of
      (*=================================================================================*)
      0:
      (*=================================================================================*)
        AP_SemaHandle1 := _MultiTask.CREATESEMAPHORE(MTSEMATYPE_MUTEX, 1, 0, pSemaName);
        if (AP_SemaHandle1 = NIL) then
          Retcode := TCP_CLT_ERR_SEMA_CREATE;
        end_if;

      (*=================================================================================*)
      1:
      (*=================================================================================*)
        AP_SemaSockOpt := _MultiTask.CREATESEMAPHORE(MTSEMATYPE_MUTEX, 1, 0, pSemaName);
        if (AP_SemaSockOpt = NIL) then
          Retcode := TCP_CLT_ERR_SEMA_CREATE;
        end_if;

      (*=================================================================================*)
      else
      (*=================================================================================*)
        Retcode := TCP_CLT_ERR_SEMA_INVALID_IDX;

    end_case;
  else
    Retcode := TCP_CLT_ERR_SEMA_INVALID_NAME;
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::AP_SemaWait
	VAR_INPUT
		SemaHandle 	: MT_SEMAHANDLE;
	END_VAR

  if (SemaHandle <> NIL) then
    _MultiTask.WAIT(SemaHandle);
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::AP_SemaSignal
	VAR_INPUT
		SemaHandle 	: MT_SEMAHANDLE;
	END_VAR

  if (SemaHandle <> NIL) then
    _MultiTask.SIGNAL(SemaHandle);
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::DelConnIntern
	VAR_INPUT
		pDelConn 	: ^_CONNECTION;
	END_VAR
VAR
	pSearchConn : ^_CONNECTION;
END_VAR

  if (pDelConn <> NIL) then

    AP_SemaWait(AP_SemaHandle1);

    if (pDelConn^.pNextConn = pDelConn) then
      // - ONE ACTIVE CONNECTION
    else
      pSearchConn := pDelConn;
      while pSearchConn^.pNextConn <> pDelConn do
        pSearchConn := pSearchConn^.pNextConn;
      end_while;
      pSearchConn^.pNextConn := pDelConn^.pNextConn;
      pActConn := pDelConn^.pNextConn;
      bdStatus.InhibNextConn := true;
    end_if;

    ConnInfoCallback(pDelConn, TCP_CLT_INFO_DELETED, 0);
    INITConnection(pDelConn);
    AP_SemaSignal(AP_SemaHandle1);

    ActConn -= 1;

  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::AddConnIntern
	VAR_INPUT
		pIPAddress 	: ^CHAR;
		pCACertPEMFilename 	: ^CHAR;
		pClientCertChainPEMFilename 	: ^CHAR;
		pClientCertKeyPEMFilename 	: ^CHAR;
		pKeyDecryptPwd 	: ^CHAR;
		pCallbackThis 	: ^_TCPIPClientInterface;
		udTimeout 	: UDINT;
		ConnSSL 	: BOOL;
	END_VAR
	VAR_OUTPUT
		dHandle 	: DINT;
	END_VAR
VAR
  pFirstConn                    : ^_CONNECTION;
  pNewConn                      : ^_CONNECTION;
  pSearchConn                   : ^_CONNECTION;
  i                             : USINT;
END_VAR

  dHandle := 0;

  if (pIPAddress = NIL) | (pConnectionBuffer = NIL) | (Control = _STATE_ERROR_CREATING_MUTEX) | (Control = _STATE_ERROR_ALLOCATING_MEMORY) then
    return;
  end_if;

  if (ActConn < MaxConn) then

    AP_SemaWait(AP_SemaHandle1);

    for i := 0 to (MaxConn-1) do
      pFirstConn := pConnectionBuffer + (i * sizeof(_CONNECTION));
      if (pFirstConn^.bInUse = true) then
        exit;
      else
        pFirstConn := NIL;
      end_if;
    end_for;


    for i := 0 to (MaxConn-1) do
      pNewConn := pConnectionBuffer + (i * sizeof(_CONNECTION));
      if (pNewConn^.bInUse = false) then
        exit;
      end_if;
    end_for;

    pNewConn^.bInUse          := true;
    pNewConn^.udTimeout       := udTimeout;
    pNewConn^.pCallbackThis   := pCallbackThis;
    pNewConn^.FSM_TCP         := _STATE_IDLE;
    pNewConn^.ConnSockOpt     := MainSockOpt;
    pNewConn^.KeepAlivePara   := KeepAlivePara;
    pNewConn^.CloseSocketType := CloseSocketType;
    SigCLib.StrCpy(#pNewConn^.szIPAddress[0], pIPAddress);
    pNewConn^.bdSettings.SockOptChanged := true;

    if (ConnSSL = true) then
      pNewConn^.bdSettings.ConnSSL := true;
      if (pCACertPEMFilename <> NIL) then
        SigCLib.StrCpy(#pNewConn^.szCACertPEMFileName[0], pCACertPEMFilename);
      end_if;
      if (pClientCertChainPEMFilename <> NIL) then
        SigCLib.StrCpy(#pNewConn^.szClientCertChainPEMFilename[0], pClientCertChainPEMFilename);
      end_if;
      if (pClientCertKeyPEMFilename <> NIL) then
        SigCLib.StrCpy(#pNewConn^.szClientCertKeyPEMFilename[0], pClientCertKeyPEMFilename);
      end_if;
      if (pKeyDecryptPwd <> NIL) then
        SigCLib.StrCpy(#pNewConn^.szKeyDecryptPwd[0], pKeyDecryptPwd);
      end_if;
    end_if;

    if (pFirstConn = NIL) then
      pNewConn^.pNextConn := pNewConn;
    else
      pSearchConn := pFirstConn;
      while (pSearchConn^.pNextConn <> pFirstConn) do
        pSearchConn := pSearchConn^.pNextConn;
      end_while;
      pNewConn^.pNextConn    := pFirstConn;
      pSearchConn^.pNextConn := pNewConn;
    end_if;

    dHandle := pNewConn$DINT;
    ActConn += 1;

    AP_SemaSignal(AP_SemaHandle1);

  else
    LastError := TCP_CLT_ERR_MAX_CONN;
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::CheckParaConnSSL
	VAR_INPUT
		pCACertPEMFilename 	: ^CHAR;
		pClientCertChainPEMFilename 	: ^CHAR;
		pClientCertKeyPEMFilename 	: ^CHAR;
		pKeyDecryptPwd 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (pClientCertChainPEMFilename <> NIL) then
    if (pClientCertKeyPEMFilename = NIL) then
      Retcode := TCP_CLT_ERR_INVALID_PARA_SSL;
    end_if;
  end_if;

  if (pClientCertKeyPEMFilename <> NIL) then
    if (pClientCertChainPEMFilename = NIL) then
      Retcode := TCP_CLT_ERR_INVALID_PARA_SSL;
    end_if;
  end_if;

  if (pKeyDecryptPwd <> NIL) then
    if (pClientCertChainPEMFilename = NIL) then
      Retcode := TCP_CLT_ERR_INVALID_PARA_SSL;
    end_if;
    if (pClientCertKeyPEMFilename = NIL) then
      Retcode := TCP_CLT_ERR_INVALID_PARA_SSL;
    end_if;
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::FindFirstConn
	VAR_OUTPUT
		pFirstConn 	: ^_CONNECTION;
	END_VAR
VAR
	i           : USINT;
  pSearchConn : ^_CONNECTION;
END_VAR

  pFirstConn := NIL;

  for i := 0 to (MaxConn-1) do
    pSearchConn := pConnectionBuffer + (i * sizeof(_CONNECTION));
    if (pSearchConn^.bInUse = true) then
      pFirstConn := pSearchConn;
    end_if;
  end_for;

END_FUNCTION

FUNCTION _TCPIPClient::CheckParaConnTCP
	VAR_INPUT
		pIPAddress 	: ^CHAR;
		pCallbackThis 	: ^void;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR
VAR
	udStrLen        : UDINT;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (pIPAddress = NIL) then
    Retcode := TCP_CLT_ERR_INVALID_PARA_TCP;
  else
    udStrLen := SigCLib.StrLen(pIPAddress);
    if (udStrLen = 0) then
      Retcode := TCP_CLT_ERR_INVALID_PARA_TCP;
    end_if;
  end_if;

  if (pCallbackThis = NIL) then
    Retcode := TCP_CLT_ERR_INVALID_PARA_TCP;
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::ConnErrCallback
	VAR_INPUT
		pConn 	: ^_CONNECTION;
		ErrGroup 	: DINT;
		ErrCode 	: DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := TCP_CLT_NO_ERROR;
  
  if (pConn <> NIL) then
    if (pConn^.pCallbackThis <> NIL) then
      pConn^.pCallbackThis$^_TCPIPClientInterface^.ErrCallback(pConn^.FSM_TCP, ErrGroup, ErrCode);
    end_if;
  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION
FUNCTION _TCPIPClient::ConnInfoCallback
	VAR_INPUT
		pConn 	: ^_CONNECTION;
		InfoPara1 	: DINT;
		InfoPara2 	: DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (pConn <> NIL) then
    if (pConn^.pCallbackThis <> NIL) then
      pConn^.pCallbackThis$^_TCPIPClientInterface^.InfoCallback(pConn^.FSM_TCP, InfoPara1, InfoPara2);
    end_if;
  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION
FUNCTION _TCPIPClient::AP_NReadAvailable
	VAR_INPUT
		pConn 	: ^_CONNECTION;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  if (pConn <> NIL) then
    if (pConn^.bdSettings.ConnSSL = false) then
      Retcode := OS_TCP_USER_NREAD_AVAILABLE(pConn^.dSocket);
    else
      Retcode := SizeOfTXBuffer$DINT;
    end_if;
  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION _TCPIPClient::INITConnection
	VAR_INPUT
		pConnection 	: ^_CONNECTION;
	END_VAR

  pConnection^.bInUse     := false;
  pConnection^.bConnected := false;
  pConnection^.dSocket    := 0;
  pConnection^.FSM_TCP    := _STATE_IDLE;

  pConnection^.pCallbackThis := NIL;

  pConnection^.udTimeout   := 0;
  pConnection^.udTimeStamp := 0;

  pConnection^.RingbufferForSending.udUsed := 0;
  pConnection^.RingbufferForSending.pRead  := pConnection^.RingbufferForSending.pMem;
  pConnection^.RingbufferForSending.pWrite := pConnection^.RingbufferForSending.pMem;
  pConnection^.BufferHeader.DataSize       := 0;
  pConnection^.pSendReceiveBufferHelp      := pConnection^.pSendReceiveBuffer;

  pConnection^.ConnSockOpt := MainSockOpt;
  pConnection^.pNextConn   := NIL;

  pConnection^.bdSettings.DelConn        := false;
  pConnection^.bdSettings.ConnSSL        := false;
  pConnection^.bdSettings.SockOptChanged := false;

  SigCLib.MemSet(#pConnection^.szIPAddress[0], 0x00, 0x10);
  SigCLib.MemSet(#pConnection^.szCACertPEMFilename, 0x00, sizeof(_CONNECTION.szCACertPEMFilename));
  SigCLib.MemSet(#pConnection^.szClientCertChainPEMFilename, 0x00, sizeof(_CONNECTION.szClientCertChainPEMFilename));
  SigCLib.MemSet(#pConnection^.szClientCertKeyPEMFilename, 0x00, sizeof(_CONNECTION.szClientCertKeyPEMFilename));
  SigCLib.MemSet(#pConnection^.szKeyDecryptPwd, 0x00, sizeof(_CONNECTION.szKeyDecryptPwd));

  pConnection^.KeepAlivePara   := KeepAlivePara;
  pConnection^.CloseSocketType := CloseSocketType;

END_FUNCTION

FUNCTION _TCPIPClient::SendSSL
	VAR_INPUT
		pConnection 	: ^_CONNECTION;
		pData 	: ^CHAR;
		udSize 	: UDINT;
		udTimeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
  
  dRetcode := OS_SSL_USER_WRITE(pConnection^.dSocket,
                                pData,
                                to_dint(udSize),
                                udTimeout);

  if (dRetcode = udSize$DINT) then
    pConnection^.udTimeStamp := ops.tAbsolute;
  else
    udSendError += 1;
    pConnection^.FSM_TCP := _STATE_SHUTDOWN;
  end_if;

END_FUNCTION
